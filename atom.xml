<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>qinggniq&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qinggniq.com/"/>
  <updated>2020-01-12T14:05:49.330Z</updated>
  <id>https://qinggniq.com/</id>
  
  <author>
    <name>qinggniq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>五重反转——从一个简单的Go程序开始</title>
    <link href="https://qinggniq.com/2020/01/12/%E4%BA%94%E9%87%8D%E5%8F%8D%E8%BD%AC%E2%80%94%E2%80%94%E4%BB%8E%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Go%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%A7%8B/"/>
    <id>https://qinggniq.com/2020/01/12/五重反转——从一个简单的Go程序开始/</id>
    <published>2020-01-12T13:50:46.000Z</published>
    <updated>2020-01-12T14:05:49.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从一个简单的go程序开始"><a class="markdownIt-Anchor" href="#从一个简单的go程序开始"></a> 从一个简单的Go程序开始</h1><blockquote><p>There is no such thing as absolute truth.”<a href="https://evidenceandanswers.org/article/truth-absolute-or-relative/#note1" target="_blank" rel="noopener"><strong>1</strong></a></p></blockquote><h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>《程序设计语言》课的一个考试题。开始以为很简单，讨论实践过后发现并没有那么简单。</p><a id="more"></a><h2 id="细节"><a class="markdownIt-Anchor" href="#细节"></a> 细节</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(i)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Microsecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上的Go程序，它会怎么输出？</p><blockquote><ol><li><p>顺序输出0-9</p></li><li><p>乱序输出0-9</p></li><li><p>全部输出10</p></li><li><p>乱序输出0-10，输出10个</p></li><li><p>有序输出0-10的数，其中0-10的数出现次数不确定</p></li></ol></blockquote><h3 id="level1直觉"><a class="markdownIt-Anchor" href="#level1直觉"></a> LEVEL1：直觉</h3><p>如果你不知道<code>go func</code>是什么意思，那么顺序输出1-9似乎很符合直觉。</p><h3 id="level2直觉-多线程"><a class="markdownIt-Anchor" href="#level2直觉-多线程"></a> LEVEL2：直觉 + 多线程</h3><p>然而你刚好学过Go语言基础，知道<code>go</code>是Go语言的一个关键字，它开启一个<a href="https://tour.golang.org/concurrency/1" target="_blank" rel="noopener"><code>goroutine</code></a>（可以理解为它是一个轻量级的线程），等待调度器来执行它。那么答案2似乎成了合适的解答，因为不能确定哪个<code>goroutine</code>会被调度。</p><h3 id="level3直觉-多线程-词法作用域"><a class="markdownIt-Anchor" href="#level3直觉-多线程-词法作用域"></a> LEVEl3：直觉 + 多线程 + 词法作用域</h3><p>然而假如你写过Go/Python/Js等支持<a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)" target="_blank" rel="noopener">闭包</a>的语言，并且被坑过，或者上过程序设计语言课，知道<a href>词法作用域</a>，那么你会知道这几个<code>func</code>里面的<code>i</code>都是一个<code>i</code>，闭包在执行的时候如果在自己的作用域里面找不到<code>i</code>的定义，那么就会往自己的作用域外面找，也就是<code>for</code>循环里面的作用域，然后把<code>for</code>循环里面的<code>i</code>作为自己的<code>i</code>。所以如果<code>for</code>循环结束之后开始调度那些goroutine的话，由于垃圾回收，<code>i</code>的值不会在<code>for</code>循环结束后销毁，函数里面的<code>i</code>都是10。（可以简单理解就是<code>func</code>里面的<code>i</code>不是值传递，而是指针）。</p><p>那么选择3——全部输出10变的合情合理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(i)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Minute)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码会乱序输出0-9，为什么呢，因为<code>i</code>作为参数传入函数会发生拷贝，这时候拷贝的就是实际的值了，所以每个<code>goroutine</code>里面的<code>i</code>都是不一样的，有着不同的存储的地址（不考虑编译器优化）。</p><h3 id="level4直觉-多线程-词法作用域-go-version-112"><a class="markdownIt-Anchor" href="#level4直觉-多线程-词法作用域-go-version-112"></a> LEVEL4：直觉 + 多线程 + 词法作用域 + Go version &gt;= 1.12</h3><p>Go在1.12接受了<a href="https://github.com/golang/go/issues/24543" target="_blank" rel="noopener">非协作抢占式调度</a>，所以并不能假定main goroutine的执行会不会被调度到自己开的goroutine上面去执行，那么如果在执行的时候获得了<code>i</code>的实际值并拷贝到<code>println</code>的栈里面，而此时并没有结束循环，所以<code>i</code>的值可能不是10，并且由于调度的最小抢占单位并不是<strong>函数</strong>，而是指令，所以我们不能确定实际把字符输出到到<code>stdout</code>的指令什么时候执行。所以乱序输出1-10似乎是问题的答案。</p><h3 id="level5直觉-多线程-词法作用域-go-version-112-runtimeprintlock"><a class="markdownIt-Anchor" href="#level5直觉-多线程-词法作用域-go-version-112-runtimeprintlock"></a> LEVEL5：直觉 + 多线程 + 词法作用域 + Go version &gt;= 1.12 + runtime.printlock</h3><p>但是如果看过这个程序的plan9汇编，就会发现在<code>func</code>的汇编里面<code>println(i)</code>对应的汇编代码是这样的。</p><p><img src="https://github.com/qinggniq/Note/blob/master/IMAGE/go-asm.png?raw=true" alt="image-20200112212540571"></p><p>而<code>println</code>第一句调用的<code>runtime.printlock</code>的源码是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The compiler emits calls to printlock and printunlock around</span></span><br><span class="line"><span class="comment">// the multiple calls that implement a single Go print or println</span></span><br><span class="line"><span class="comment">// statement. Some of the print helpers (printslice, for example)</span></span><br><span class="line"><span class="comment">// call print recursively. There is also the problem of a crash</span></span><br><span class="line"><span class="comment">// happening during the print routines and needing to acquire</span></span><br><span class="line"><span class="comment">// the print lock to print information about the crash.</span></span><br><span class="line"><span class="comment">// For both these reasons, let a thread acquire the printlock 'recursively'.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">mp := getg().m</span><br><span class="line">mp.locks++ <span class="comment">// do not reschedule between printlock++ and lock(&amp;debuglock).</span></span><br><span class="line">mp.printlock++</span><br><span class="line"><span class="keyword">if</span> mp.printlock == <span class="number">1</span> &#123;</span><br><span class="line">lock(&amp;debuglock)</span><br><span class="line">&#125;</span><br><span class="line">mp.locks-- <span class="comment">// now we know debuglock is held and holding up mp.locks for us.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//source https://golang.org/src/runtime/print.go</span></span><br></pre></td></tr></table></figure><p>通过注释可知<code>printlock</code>保护了和<code>printunlock</code>之间的临界区，保证了线程安全，所以<code>println</code>是个线程安全的函数。</p><p>那么假使一个goroutine A在<code>i == 5</code>的时候抢占了main goroutine执行，即使main goroutine被分配到另一CPU执行，并且被在<code>i &gt; 5</code>时创建的goroutine B打断，那么打断main goroutine的B的也不可能执行到<code>runtime.printlock</code>之后的代码，而当<code>i == 5</code>的时候调用的A执行完<code>runtime.printunlock</code>之后（注意虽然goroutine A是在<code>i==5</code>的时候被调用的，但是输出的时候不一定输出<code>5</code>，因为<code>runtime.printlock</code>只保护后面的临界区，而不保护<code>i</code>的变化，<code>i</code>有可能被运行在另一个CPU里面的main-goroutine修改）。</p><p>这样的话，每个goroutine的输出语句被串行化了，而<code>i</code>一直是递增的，所以输出出去的<code>i</code>也是递增的。这也就是选择5的缘由。</p><h3 id="level6直觉-多线程-词法作用域-go-version-112-runtimeprintlock"><a class="markdownIt-Anchor" href="#level6直觉-多线程-词法作用域-go-version-112-runtimeprintlock"></a> LEVEL6：直觉 + 多线程 + 词法作用域 + Go version &gt;= 1.12 + runtime.printlock + ？</h3><p>可能等到我看了Go的调度器源码之后会有新的理解吧。</p><h3 id="ps"><a class="markdownIt-Anchor" href="#ps"></a> ps</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Microsecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个代码的输出是什么呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;从一个简单的go程序开始&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#从一个简单的go程序开始&quot;&gt;&lt;/a&gt; 从一个简单的Go程序开始&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;There is no such thing as absolute truth.”&lt;a href=&quot;https://evidenceandanswers.org/article/truth-absolute-or-relative/#note1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#背景&quot;&gt;&lt;/a&gt; 背景&lt;/h2&gt;
&lt;p&gt;《程序设计语言》课的一个考试题。开始以为很简单，讨论实践过后发现并没有那么简单。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Go" scheme="https://qinggniq.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>杀鸡用牛刀--LeetCode394的antlr解法</title>
    <link href="https://qinggniq.com/2019/12/22/%E6%9D%80%E9%B8%A1%E7%94%A8%E7%89%9B%E5%88%80-LeetCode394%E7%9A%84antlr%E8%A7%A3%E6%B3%95/"/>
    <id>https://qinggniq.com/2019/12/22/杀鸡用牛刀-LeetCode394的antlr解法/</id>
    <published>2019-12-22T10:52:11.000Z</published>
    <updated>2020-01-12T13:51:44.025Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a class="markdownIt-Anchor" href="#起因"></a> 起因</h2><ul><li>刷题的时候刷到了这个题<a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">decode-string</a>，之前实习面试的时候写了个UB，于是顺理成章的挂了，印象深刻。</li><li>程序语言原理课大作业用了用Antlr写语法分析器，还挺好用的。</li></ul><p>写个语法分析器来做这个题还挺有意思的。</p><a id="more"></a><h2 id="题面"><a class="markdownIt-Anchor" href="#题面"></a> 题面</h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><p><strong>示例:</strong></p><pre>s = "3[a]2[bc]", 返回 "aaabcbc".s = "3[a2[c]]", 返回 "accaccacc".s = "2[abc]3[cd]ef", 返回 "abcabccdcdcdef".</pre><h2 id="定义词法"><a class="markdownIt-Anchor" href="#定义词法"></a> 定义词法</h2><p>这个题目里面就两个元素，一个<strong>内容</strong>，一个<strong>重复次数</strong>，由于可能出现其他的特殊符号，所以在这里我直接用大小写字符作为所有可能出现的<strong>内容</strong>，用简单的数字字符<code>[0-9]</code>作为表示<strong>重复次数</strong>的最小表示元素。</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>c</mi><mi>h</mi><mi>a</mi><mi>r</mi><mo>:</mo><mo>:</mo><msup><mo>=</mo><mo mathvariant="normal">′</mo></msup><msup><mi>a</mi><mo mathvariant="normal">′</mo></msup><msup><mi mathvariant="normal">∣</mi><mo mathvariant="normal">′</mo></msup><msup><mi>b</mi><mo mathvariant="normal">′</mo></msup><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msup><mi mathvariant="normal">.</mi><mo mathvariant="normal">′</mo></msup><msup><mi>z</mi><mo mathvariant="normal">′</mo></msup><msup><mi mathvariant="normal">∣</mi><mo mathvariant="normal">′</mo></msup><msup><mi>A</mi><mo mathvariant="normal">′</mo></msup><msup><mi mathvariant="normal">∣</mi><mo mathvariant="normal">′</mo></msup><msup><mi>B</mi><mo mathvariant="normal">′</mo></msup><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msup><mi mathvariant="normal">.</mi><mo mathvariant="normal">′</mo></msup><msup><mi>Z</mi><mo mathvariant="normal">′</mo></msup></mrow><mspace linebreak="newline"></mspace><mrow><mi>d</mi><mi>i</mi><mi>g</mi><mi>i</mi><mi>t</mi><mo>:</mo><mo>:</mo><mo>=</mo><mn>1</mn><mi mathvariant="normal">∣</mi><mn>2</mn><mi mathvariant="normal">∣</mi><mn>3</mn><mi mathvariant="normal">∣</mi><mn>4</mn><mi mathvariant="normal">∣</mi><mn>5</mn><mi mathvariant="normal">∣</mi><mn>6</mn><mi mathvariant="normal">∣</mi><mn>7</mn><mi mathvariant="normal">∣</mi><mn>8</mn><mi mathvariant="normal">∣</mi><mn>9</mn><mi mathvariant="normal">∣</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">{char ::= &#x27;a&#x27;|&#x27;b&#x27;...&#x27;z&#x27;|&#x27;A&#x27;|&#x27;B&#x27;...&#x27;Z&#x27;}\\{digit ::= 1|2|3|4|5|6|7|8|9|0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.051892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mrel">:</span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord">.</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord">.</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mrel">:</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span><span class="mord">∣</span><span class="mord">2</span><span class="mord">∣</span><span class="mord">3</span><span class="mord">∣</span><span class="mord">4</span><span class="mord">∣</span><span class="mord">5</span><span class="mord">∣</span><span class="mord">6</span><span class="mord">∣</span><span class="mord">7</span><span class="mord">∣</span><span class="mord">8</span><span class="mord">∣</span><span class="mord">9</span><span class="mord">∣</span><span class="mord">0</span></span></span></span></span></span></p><h2 id="定义语法"><a class="markdownIt-Anchor" href="#定义语法"></a> 定义语法</h2><p>我们把这个经过编码的字符串称为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mi>n</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Unit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span></span></span></span>，而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mi>n</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Unit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span></span></span></span>一般要么由单次出现的<strong>内容组成</strong>，要么由多次出现的<strong>内容</strong>组成，而<strong>内容</strong>里面是一个更小的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mi>n</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Unit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span></span></span></span>。所以语法定义如下：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mi>n</mi><mi>i</mi><mi>t</mi><mtext>  </mtext><mo>:</mo><mo>:</mo><mo>=</mo><mtext> </mtext><mi>c</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>t</mi><mspace linebreak="newline"></mspace><mspace width="7.397716535433071em"></mspace><mi mathvariant="normal">∣</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>s</mi><msup><mtext> </mtext><mo mathvariant="normal">′</mo></msup><msup><mo>[</mo><mo mathvariant="normal">′</mo></msup><mi>u</mi><mi>n</mi><mi>i</mi><msup><mi>t</mi><mo mathvariant="normal">′</mo></msup><msup><mo>]</mo><mo mathvariant="normal">′</mo></msup><mspace linebreak="newline"></mspace><mspace width="6.544133858267717em"></mspace><mi mathvariant="normal">∣</mi><mi>c</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>t</mi><mtext> </mtext><mi>u</mi><mi>n</mi><mi>i</mi><mi>t</mi><mspace linebreak="newline"></mspace><mspace width="9.958464566929134em"></mspace><mi mathvariant="normal">∣</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>s</mi><mtext> </mtext><msup><mtext> </mtext><mo mathvariant="normal">′</mo></msup><msup><mo>[</mo><mo mathvariant="normal">′</mo></msup><mi>u</mi><mi>n</mi><mi>i</mi><msup><mi>t</mi><mo mathvariant="normal">′</mo></msup><msup><mo>]</mo><mo mathvariant="normal">′</mo></msup><mtext>  </mtext><mi>u</mi><mi>n</mi><mi>i</mi><mi>t</mi><mspace linebreak="newline"></mspace><mspace linebreak="newline"></mspace><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>s</mi><mtext> </mtext><mo>:</mo><mo>:</mo><mo>=</mo><mi>d</mi><mi>i</mi><mi>g</mi><mi>i</mi><mi>t</mi><mo>+</mo><mspace linebreak="newline"></mspace><mi>c</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo>:</mo><mo>:</mo><mo>=</mo><mi>c</mi><mi>h</mi><mi>a</mi><mi>r</mi><mo>+</mo><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">unit  \space \space::=  \space content               \\\hspace{2.6cm}| times \space&#x27;[&#x27; unit &#x27;]&#x27;\\\hspace{2.3cm}| content \space unit \\\hspace{3.5cm}| times  \space \space&#x27;[&#x27; unit &#x27;]&#x27; \space \space unit\\\\times \space::= digit+\\content::= char+\\</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace"> </span><span class="mspace"> </span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace"> </span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.051892em;vertical-align:-0.25em;"></span><span class="mspace" style="margin-right:7.397716535433071em;"></span><span class="mord">∣</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord"><span class="mspace"> </span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen"><span class="mopen">[</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mspace" style="margin-right:6.544133858267717em;"></span><span class="mord">∣</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace"> </span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.051892em;vertical-align:-0.25em;"></span><span class="mspace" style="margin-right:9.958464566929134em;"></span><span class="mord">∣</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mspace"> </span><span class="mord"><span class="mspace"> </span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen"><span class="mopen">[</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mspace"> </span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span></span><span class="mspace newline"></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace"> </span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">+</span></span><span class="mspace newline"></span></span></span></span></p><h2 id="使用antlr4生成语法分析器"><a class="markdownIt-Anchor" href="#使用antlr4生成语法分析器"></a> 使用Antlr4生成语法分析器</h2><h3 id="g4文件"><a class="markdownIt-Anchor" href="#g4文件"></a> g4文件</h3><p>就是对语法的翻译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">grammar zip;</span><br><span class="line"></span><br><span class="line">unit: content                 #singal</span><br><span class="line">    | times &apos;[&apos; unit &apos;]&apos;      #timesSignal</span><br><span class="line">    | content unit            #singalfComb</span><br><span class="line">    | times &apos;[&apos; unit &apos;]&apos; unit #timesComb</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">times: Digit</span><br><span class="line">|Digit times;</span><br><span class="line"></span><br><span class="line">content: Char+;</span><br><span class="line"></span><br><span class="line">Char</span><br><span class="line">    :   [a-zA-Z]</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">Digit</span><br><span class="line">    :   [0-9]</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><h3 id="简单的示例"><a class="markdownIt-Anchor" href="#简单的示例"></a> 简单的示例</h3><p>题面示例中的第一个例子<code>&quot;3[a]2[bc]&quot;</code>的抽象语法树如下：</p><p><img src="https://github.com/qinggniq/Note/blob/master/PL/decode/image/parseTree.png?raw=true" alt="parseTree"></p><h2 id="自定义unit结构"><a class="markdownIt-Anchor" href="#自定义unit结构"></a> 自定义<code>Unit</code>结构</h2><p>Antlr为我们生成的语法分析器只是提供了我们访问抽象语法树的接口，如果我们想自定义访问抽象语法树节点时需要进行的操作，那么需要自己实现它提供的<code>visitor</code>基类。但是首先需要自定义我们用来表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mi>n</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Unit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span></span></span></span>结构的结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ast</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UnitType <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">SingalType = <span class="literal">iota</span></span><br><span class="line">TimesType</span><br><span class="line">TimesCombType</span><br><span class="line">SingalCombType</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Unit <span class="keyword">struct</span> &#123;</span><br><span class="line">Times <span class="keyword">int</span></span><br><span class="line">Other *Unit</span><br><span class="line">Mine  *Unit</span><br><span class="line">Cur   <span class="keyword">string</span></span><br><span class="line">Ty    UnitType</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *Unit)</span> <span class="title">Eval</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> res <span class="keyword">string</span></span><br><span class="line"><span class="keyword">switch</span> u.Ty &#123;</span><br><span class="line"><span class="keyword">case</span> SingalType:</span><br><span class="line">res = u.Cur</span><br><span class="line"><span class="keyword">case</span> TimesType:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; u.Times; i++ &#123;</span><br><span class="line">res += u.Mine.Eval()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> SingalCombType:</span><br><span class="line">res = u.Cur</span><br><span class="line">res += u.Other.Eval()</span><br><span class="line"><span class="keyword">case</span> TimesCombType:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; u.Times; i++ &#123;</span><br><span class="line">res += u.Mine.Eval()</span><br><span class="line">&#125;</span><br><span class="line">res += u.Other.Eval()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Unit</code>结构体实际上是对语法结构<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mi>n</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Unit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span></span></span></span>的直接翻译,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mi>n</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Unit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span></span></span></span>有四个并行的<a href="%5Bhttps://zh.wikipedia.org/wiki/%E5%BD%A2%E5%BC%8F%E6%96%87%E6%B3%95%5D(https://zh.wikipedia.org/wiki/%E5%BD%A2%E5%BC%8F%E6%96%87%E6%B3%95)">产生式</a>，于是<code>Unit</code>有四种类型，<code>Unit.Mine</code>用来表示方扣号内的<code>Unit</code>，而<code>Unit.Other</code>用来表示方扣号外并行的<code>Unit</code>。</p><p>而<code>Eval</code>就是根据不同情形计算实际解码后的字符串。</p><h3 id="重写visitor"><a class="markdownIt-Anchor" href="#重写visitor"></a> 重写Visitor</h3><p><strong>Visitor</strong>是Antlr提供给我们访问抽象语法树的接口，它还提供<strong>Listener</strong>接口，但这里只说<strong>Visitor</strong>，Antlr提供给我们的原始Visitor只是遍历抽象语法树而已，我们需要自己重写遍历语法分析树节点时调用的方法，比如我们想在访问到<code>content</code>节点的时候打印出<code>content</code>的内容，就可以重写一下<code>VisitContent(ctx *ContentContext)</code>方法，在里面加上<code>println(ctx.GetText())</code>就可以了。</p><p>现在我们需要重写<strong>Visitor</strong>接口里面的方法让它们用节点中的值去初始化我们之前定义的<code>Unit</code>接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//visitor.go</span></span><br><span class="line"><span class="keyword">package</span> parser</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"decode/src/ast"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"github.com/antlr/antlr4/runtime/Go/antlr"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ZipVisitor <span class="keyword">struct</span> &#123;</span><br><span class="line">BasezipVisitor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *ZipVisitor)</span> <span class="title">Visit</span><span class="params">(tree antlr.ParseTree)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">fmt.Println(reflect.TypeOf(tree), reflect.ValueOf(tree).Kind())</span><br><span class="line">res := tree.Accept(v)</span><br><span class="line">fmt.Println(reflect.TypeOf(res), reflect.ValueOf(res).Kind())</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *ZipVisitor)</span> <span class="title">VisitTimes</span><span class="params">(ctx *TimesContext)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">res, _ := strconv.ParseInt(ctx.GetText(), <span class="number">10</span>, <span class="number">8</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *ZipVisitor)</span> <span class="title">VisitContent</span><span class="params">(ctx *ContentContext)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> ctx.GetText()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *ZipVisitor)</span> <span class="title">VisitSingal</span><span class="params">(ctx *SingalContext)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">unit := &amp;ast.Unit&#123;&#125;</span><br><span class="line">unit.Cur = ctx.GetText()</span><br><span class="line">unit.Ty = ast.SingalType</span><br><span class="line"><span class="keyword">return</span> unit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *ZipVisitor)</span> <span class="title">VisitTimesSignal</span><span class="params">(ctx *TimesSignalContext)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">unit := &amp;ast.Unit&#123;&#125;</span><br><span class="line">unit.Times = ctx.Times().Accept(v).(<span class="keyword">int</span>)</span><br><span class="line">unit.Mine = ctx.Unit().Accept(v).(*ast.Unit)</span><br><span class="line">unit.Ty = ast.TimesType</span><br><span class="line"><span class="keyword">return</span> unit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *ZipVisitor)</span> <span class="title">VisitSingalfComb</span><span class="params">(ctx *SingalfCombContext)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">unit := &amp;ast.Unit&#123;&#125;</span><br><span class="line">unit.Cur = ctx.Content().Accept(v).(<span class="keyword">string</span>)</span><br><span class="line">unit.Other = ctx.Unit().Accept(v).(*ast.Unit)</span><br><span class="line">unit.Ty = ast.SingalCombType</span><br><span class="line"><span class="keyword">return</span> unit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *ZipVisitor)</span> <span class="title">VisitTimesComb</span><span class="params">(ctx *TimesCombContext)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"top"</span>)</span><br><span class="line">unit := &amp;ast.Unit&#123;&#125;</span><br><span class="line">unit.Times = ctx.Times().Accept(v).(<span class="keyword">int</span>)</span><br><span class="line">unit.Mine = ctx.Unit(<span class="number">0</span>).Accept(v).(*ast.Unit)</span><br><span class="line">unit.Other = ctx.Unit(<span class="number">1</span>).Accept(v).(*ast.Unit)</span><br><span class="line">unit.Ty = ast.TimesCombType</span><br><span class="line"><span class="keyword">return</span> unit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"decode/src/ast"</span></span><br><span class="line"><span class="string">"decode/src/parser"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/antlr/antlr4/runtime/Go/antlr"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">args := os.Args[<span class="number">1</span>]</span><br><span class="line">Parse(args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(expr <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">input := antlr.NewInputStream(expr)</span><br><span class="line">lexer := parser.NewzipLexer(input)</span><br><span class="line">tokenStream := antlr.NewCommonTokenStream(lexer, antlr.TokenDefaultChannel)</span><br><span class="line">parserer := parser.NewzipParser(tokenStream)</span><br><span class="line">tree := parserer.Unit()</span><br><span class="line">v := &amp;parser.ZipVisitor&#123;&#125;</span><br><span class="line">unit := v.Visit(tree).(*ast.Unit)</span><br><span class="line"><span class="built_in">println</span>(unit.Eval())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="build-run"><a class="markdownIt-Anchor" href="#build-run"></a> build &amp;&amp; run</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go build main.go</span></span><br></pre></td></tr></table></figure><p><img src="https://github.com/qinggniq/Note/blob/master/PL/decode/image/run-result.png?raw=true" alt="image-20191222203002554"></p><p>代码在<a href>这里</a></p><h2 id="结语"><a class="markdownIt-Anchor" href="#结语"></a> 结语</h2><p>虽然这个题实在不至于用这种做法，但是对我的意义就是我不再害怕语法分析这个东西了（虽然不是手写的），之前挺害怕语法分析的，本科学编译的也没写过语法分析器，课也没好好上，做毕设的时候赶鸭子上架用一个完全陌生的语言（SML）给另一个完全语言（AADL）写语法分析器，虽然是做了，然而做的时候十分的痛苦，算是给我留下了心理阴影，现在这个魔障算是破处了吧（可能是错觉）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;起因&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#起因&quot;&gt;&lt;/a&gt; 起因&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;刷题的时候刷到了这个题&lt;a href=&quot;https://leetcode-cn.com/problems/decode-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;decode-string&lt;/a&gt;，之前实习面试的时候写了个UB，于是顺理成章的挂了，印象深刻。&lt;/li&gt;
&lt;li&gt;程序语言原理课大作业用了用Antlr写语法分析器，还挺好用的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;写个语法分析器来做这个题还挺有意思的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://qinggniq.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Go" scheme="https://qinggniq.com/tags/Go/"/>
    
      <category term="语法分析" scheme="https://qinggniq.com/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>19-11月总结</title>
    <link href="https://qinggniq.com/2019/11/30/19-11%E6%9C%88%E6%80%BB%E7%BB%93/"/>
    <id>https://qinggniq.com/2019/11/30/19-11月总结/</id>
    <published>2019-11-30T08:12:54.000Z</published>
    <updated>2019-11-30T08:14:02.120Z</updated>
    
    <content type="html"><![CDATA[<p>一晃眼就月底了，这个月过的真是试错的一个月啊，前期照例看论文、做笔记（翻译/抄书），倒也是照着预期的那样，听红楼梦、偶尔冥想、收回注意力，一切好好的。到第二周中间的时候应了yz的邀请一起去参加pingcap的PCP了。</p><a id="more"></a><p>说是比赛，我倒觉得像是给pingcap做外包呢，pingcap的人把一些issue根据难度分了等级（easy/medium/hard），参赛的人选取issue然后提pr，pr被merge后就会获得相应的分数。一共有三个项目可以选择——TIDB、TIKV、PD，我们考虑了一下，对数据库执行那块不太熟悉、rust没学过，唯一有点了解的是raft那些东西，所以开始的时候便选择了做PD。我们各自领了一个easy的issue，但是第一个issue过了两周才被合进去，这issue的难度确实是easy，然而和TIKV和TIDB实现对应函数的issue不同的是，pd的issue需要自己对pd项目的一部分的代码有相应的了解，并且需求并不是十分的确定，实现细节需要讨论确定，所以我们第一次的issue大部分时间就花在了和pingcap的人沟通上面和看代码上面了。第二周快结束的时候可总算是被合进去了，第三周的时候开始打算的是各自先快速解决一个easy的，然后开始做medium的，刚好我做的第一个issue可以照搬成另一个issue，于是快速把那个issue给做了。yz那边还在就实现方面和他们在讨论，然而在整了几天后便陷入了怀疑之中，思考参与这个东西的意义，因为这近三周做的工作实在是搬砖，时间都浪费在了沟通上面，在看代码的过程中有些不确定的东西需要花费很长的时间才能定位，而如果是实习的话这些问题本可以不必浪费的，给开源项目提pr确实是个有意义的事情，但是不应该占据生活的大部分时间，作为兴趣和业余才比较合适。并且关键的是我们平时也不用这个东西，如果作为学习代码的话，也有更好的实现去阅读（k8s、etcd等），这样在这全职干这个算什么事，pd这个东西恕我理解不了它的实现之美，设计之美。得出结论过后我们便停止了参赛。觉得还是改干嘛干嘛吧，做这个东西确实和搬砖没啥区别，学知识不如看书来的快，写代码不如自己写个雏形的收获大。。</p><p>由于上次的目标一个也没达成，这次就不再立flag了。慢慢来吧，这个月太急躁了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一晃眼就月底了，这个月过的真是试错的一个月啊，前期照例看论文、做笔记（翻译/抄书），倒也是照着预期的那样，听红楼梦、偶尔冥想、收回注意力，一切好好的。到第二周中间的时候应了yz的邀请一起去参加pingcap的PCP了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="life" scheme="https://qinggniq.com/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>retools包下载问题</title>
    <link href="https://qinggniq.com/2019/11/13/retools%E5%8C%85%E4%B8%8B%E8%BD%BD%E9%97%AE%E9%A2%98/"/>
    <id>https://qinggniq.com/2019/11/13/retools包下载问题/</id>
    <published>2019-11-13T09:32:54.000Z</published>
    <updated>2019-11-30T06:44:53.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p><a href="https://github.com/pingcap/pd" target="_blank" rel="noopener">tidb-pd</a>中 <code>make test</code> 使用的是 <a href="https://github.com/twitchtv/retool" target="_blank" rel="noopener">retool</a> 进行代码管理。然而在自己的机器下无法进行。</p><a id="more"></a><h2 id="环境"><a class="markdownIt-Anchor" href="#环境"></a> 环境</h2><ul><li>Ubuntu 18.04 LST</li><li>Go 13.3</li><li>shadowsocks-libev</li><li>privoxy</li></ul><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><ol><li><code>retools</code> 不支持 <strong>go mod</strong>，所以需要代理或者手动装包；</li><li>学艺不精，不知道<code>retools</code>需要的包具体有什么，路径格式是什么，版本是怎么设定的，所以希望在尽量做太多 <em>dirty work</em> 的情况下解决问题，选择代理；</li></ol><h2 id="过程"><a class="markdownIt-Anchor" href="#过程"></a> 过程</h2><p><code>retools</code> 在下载第一个包的时候使用 <code>go get -d github.com/mgechev/revive</code> 获取 <code>revive</code> 这个包，正常直接用 <code>git clone</code> 是可以直接下载的，然而 <code>go get</code> 在下载的过程中会递归下载它引入的包 <code>golang.org/x/tools/go/gcexportdata</code> ，而这个包在被墙了。</p><ol><li>开启 <code>go mod</code>，上面说的包都可以下载，然而 <code>retool</code> 下载包（也就是 <code>go get</code>）存放的路径和 <code>go mod</code> 不一样，所以 <code>retool</code> 报错找不到路径；</li><li>把上面两个包手动移动到 <code>retool</code> 报错提示的路径中去，然而 <code>retool</code> 在下载之后使用 <code>git checkout</code> 检查版本，手动移动的包无法通过检查，至于为什么？涉及到了知识盲区；</li></ol><blockquote><p>既然 <code>github.com/mgechev/revive</code> 这个包可以直接下，而 <code>golang.org</code> 的包下不了，那么在这两者中间加一句开启 <code>go mod</code> 的语句不就行了？</p></blockquote><p>然而之前提到，<code>retool</code> 直接用的 <code>go get</code> 下载，没有给我中间更换包管理软件的空隙（当然，改<code>go get</code> 的源码当然是可以实现的），所以问题就变成了这样：</p><ul><li>用 <code>go mod</code> 不能执行；</li><li>不用 <code>go mod</code> 下不下来包，并且无法通过版本检查。</li></ul><blockquote><p>那么就弄个代理吧！</p></blockquote><p>开开心心上网 <code>ctrl-c, ctrl-v</code> 了一番：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">git config --global http.proxy socks5://127.0.0.1:1080</span></span><br><span class="line"><span class="meta">$</span><span class="bash">git config --global https.proxy socks5://127.0.0.1:1080</span></span><br></pre></td></tr></table></figure><p>然而这样做只能让 <code>git clone</code> 更快，并不能解决下载 <code>golang.org</code> 的问题，因为它不走 git 那条线。</p><blockquote><p>开个全局代理就好了</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">export</span> https_proxy=socks5://127.0.0.1:1080</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">export</span> http_proxy=socks5://127.0.0.1:1080</span></span><br></pre></td></tr></table></figure><p>这样 <code>git clone</code> 都用不了，被检测到处于代理之下，怎么解决不知道，<code>glang.org</code> 包下不了，因为它走的是 <code>http/https</code> 的线，不走 <code>socks5</code> 协议。</p><h2 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h2><blockquote><p>转 <code>socks5</code> 协议到 <code>http/https</code> 协议</p></blockquote><p>这样做的前提是你有一个<code>VPN/VPS</code>，并且有<code>shadowsocks</code>。</p><p><em>下载 <code>privoxy</code></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo apt install privoxy</span></span><br></pre></td></tr></table></figure><p><em>配置</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/privoxy/config</span></span><br></pre></td></tr></table></figure><p>然后在里面搜索<code>listen-address</code>和<code>forward-socks5t</code>，取消注释或者新添一下两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># /etc/privoxy/config</span><br><span class="line">forward-socks5t   /               127.0.0.1:1080 .</span><br><span class="line">listen-address  127.0.0.1:8118</span><br></pre></td></tr></table></figure><p>ps:</p><ul><li><code>1080</code> 是 <code>shadowsocks</code> 监听的本地端口；</li><li><code>forward-socks5t</code> 那行的最后一个“.”是有的。</li></ul><p>然后：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> https_proxy=http://127.0.0.1:8118</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> http_proxy==http://127.0.0.1:8118</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo service privoxy start</span></span><br></pre></td></tr></table></figure><p>ps:</p><ul><li>要想配置长久生效，把两行 <code>export</code> 设置放到某个 <code>profile</code> 文件里就行，然后把 <code>service privoxy</code> 设置为开机启动。</li></ul><h2 id="结语"><a class="markdownIt-Anchor" href="#结语"></a> 结语</h2><p>这样不仅 <code>retools</code> 的问题解决了，之后走 <code>http/https</code> 的软件下载问题都解决了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#背景&quot;&gt;&lt;/a&gt; 背景&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/pingcap/pd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;tidb-pd&lt;/a&gt;中 &lt;code&gt;make test&lt;/code&gt; 使用的是 &lt;a href=&quot;https://github.com/twitchtv/retool&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;retool&lt;/a&gt; 进行代码管理。然而在自己的机器下无法进行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="运维" scheme="https://qinggniq.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>DDIA读书笔记——第八章-分布式系统的挑战</title>
    <link href="https://qinggniq.com/2019/11/11/DDIA%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8C%91%E6%88%98/"/>
    <id>https://qinggniq.com/2019/11/11/DDIA读书笔记——第八章-分布式系统的挑战/</id>
    <published>2019-11-11T11:34:52.000Z</published>
    <updated>2019-11-30T06:44:53.669Z</updated>
    
    <content type="html"><![CDATA[<p>开发者的核心任务是构建可靠的系统，即使系统面临着各种出错的可能，也需要完成预定的工作。</p><p>本章对分布式系统可能出现的故障做了一个全面的、近乎悲观的总结，故障可能来自：</p><ul><li><strong>网络问题</strong></li><li><strong>时钟和时序问题</strong></li></ul><p>并讨论这些问题的可控程度，接下来会探讨如何认清分布式系统的状态本质，并以此来评估发生的各种故障。</p><a id="more"></a><h2 id="故障和部分失效"><a class="markdownIt-Anchor" href="#故障和部分失效"></a> <strong>故障和部分失效</strong></h2><p>单机上的错误一般是“要么工作，要么出错”这种模式，一般不会出现中间形态。然而多节点的时候会出现系统的一部分正常一部分不正常的现象，我们称之为“部分失效”，并且这种部分失效是不确定的，如果涉及到多个节点和网络，几乎肯定会碰到有时网络正常有时候不正常的情况。</p><p>这种不确定性和部分失效极大的提高了分布式系统的复杂性。</p><h2 id="不可靠的网络"><a class="markdownIt-Anchor" href="#不可靠的网络"></a> <strong>不可靠的网络</strong></h2><p>无共享、使用网络通信是构建集群的主流方式，主要因为：不需要专门的硬件，价格低廉；可以使用跨区域的多数据中心来实现高可用性。</p><p>网络一般是异步网络，只发送但是并不保证一定可以到到，有可能：</p><ol><li>请求丢失（拔了网线）；</li><li>请求在某个队列中；</li><li>远程接受节点失效；</li><li>远程节点暂时无法响应（垃圾回收，进程暂停）；</li><li>响应在网络中丢失（交换机配置错误）；</li><li>响应被延迟处理（网络或发送者的机器超出了负载）。</li></ol><p>发送者拥有的唯一信息是，尚未收到响应，但无法判断具体原因。所以一般使用超时机制来解决，但是超时也无法确定远程节点是不是收到了请求。</p><h3 id="现实中的网络故障"><a class="markdownIt-Anchor" href="#现实中的网络故障"></a> 现实中的网络故障</h3><p>现实中网络故障十分普遍。</p><h3 id="故障检测"><a class="markdownIt-Anchor" href="#故障检测"></a> <strong>故障检测</strong></h3><p>现实中有很多需要检测节点失效的情况：</p><ul><li>负载均衡器需要避免向失效节点发送消息；</li><li>主从复制节点的时候需要检测主节点失效然后替换主节点；</li><li>由于网络的不确定性导致判断网络失效非常困难；</li><li>如果节点在处理请求的时候发生了崩溃，那么很难知道节点实际处理了多少数据；</li><li>如果服务器进程崩溃，操作系统依然正常运行，那么可以通过脚本通知其他节点。HBase使用了这种方法；</li><li>可以通过数据中心的网络交换机的管理接口查询是否存在硬件级别的链路故障；</li></ul><p>如果想知道请求是否执行成功，只靠TCP的确认报文是不能确定的，只能靠应用级别的回复。</p><h3 id="超时与无限期的延迟"><a class="markdownIt-Anchor" href="#超时与无限期的延迟"></a> <strong>超时与无限期的延迟</strong></h3><p>超时过长或过短都会有问题，过长意味着长时间的等待才能确认节点失效，过短可能会造成误判（比如因为网络延迟）。</p><p>一个节点失效会将这个节点的负载移到另一个，可能会导致级联级别的失效。</p><p>设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>为网络保证可以交付的最大延迟时间，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>为一个非故障节点能在期间完成处理的时间，那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>d</mi><mo>+</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">2d + r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>是比较合适的超时时间。</p><p><strong>网络拥塞和排队</strong><br>可能在**交换机、操作系统、虚拟机切换、流量控制（比如nagel算法）**这些地方等待。TCP的重传也会带来延迟。</p><blockquote><p>如果对于一个应用来说重传没有什么意义，那么建议使用UDP</p></blockquote><p>还有可能在共享的网络，其他人的使用会给自己带来巨大的延迟波动。</p><p>根据以上的情况，设置超时还是不要设置为定时，而应该随着持续的响应时间的变化动态决定。比如 <strong>Phi Accrual</strong> 来确定超时时间，Akka 和 Cassandra 和 TCP 都使用的是这个。</p><h3 id="同步和异步网络"><a class="markdownIt-Anchor" href="#同步和异步网络"></a> <strong>同步和异步网络</strong></h3><p>传统的电路交换十分稳定，是因为它为每个信道分配了唯一的通信链路，保证了通信的速度，这种网络本质上是同步的，它不会受到排队的影响，所以延迟是固定的，我们称为<strong>有界延迟</strong>。</p><p>但是TCP中的连接不同，TCP 连接的数据包会尝试所有可用的网络带宽，尽力在最短的时间内完成数据发送，当 TCP 连接空闲的时候通常不占用任何带宽。</p><p>如果数据中心网络和互联网基于电路交换网络，一旦电路建成可以保证最大往返时间，然而事实上是以太网和 IP 都是基于<strong>分组交换协议</strong>，这种协议注定要受到排队的影响。它不分配电路。</p><blockquote><p>为什么数据中心网络和互联网要使用分组交换呢？</p></blockquote><p>它们针对突发流量做了很多优化，电话和视频的网络带宽往往容易事前确定，然而访问网页和传输文件无法事先确定带宽需求，我们只是希望它们尽快完成。</p><p>以上便是为什么超时时间设置不能设置为固定值而要动态决定的原因了。</p><blockquote><p>分组交换和现代计算机的多核计算机的调度很像，都是充分利用带宽/CPU，达到资源利用率的最大化，这也是<strong>虚拟化</strong>技术的重要动机。</p></blockquote><h2 id="不可靠的时钟"><a class="markdownIt-Anchor" href="#不可靠的时钟"></a> <strong>不可靠的时钟</strong></h2><p>时钟和计时非常重要：</p><ol><li>请求是否超时?</li><li>服务的99%响应时间是多少？</li><li>过去五分钟内，服务平均处理多少请求？<br>…</li></ol><p>在分布式系统中时间是个棘手的问题，跨节点通信不可能即时完成，收到的时间要晚于发送的时间，但是由于网络的不确定延迟性，精确测量面临着很都挑战，使得多个节点通信的时候很难确定事情发生的先后顺序。</p><p>每个机器都有自己的时钟，但是设备可能不准确，有的快有的慢，同步时钟的常用方法是网络时间协议（NTP），根据一组专门的时间服务器来调整本地时间，时间服务器则从精确性更高的时间源（如GPS接收器）获取高精度时间。</p><h3 id="单调时钟和墙上时钟"><a class="markdownIt-Anchor" href="#单调时钟和墙上时钟"></a> <strong>单调时钟和墙上时钟</strong></h3><p>现代计算机至少有两个时钟：一个墙上时钟一个单调时钟。</p><p><strong>墙上时钟</strong><br>墙上时钟根据某个日历返回当前的日期和时间。Linux 的 <code>clock_gettime(CLOCK_REALTIME)</code> 和 Java 的 <code>System.currentTimeMillis()</code> 会返回从 1970-01-01 以来的秒数和毫秒数，不含闰秒。</p><p>墙上时钟可以和 NTP 同步，但是会有一些问题，比如本地时钟快于 NTP 服务器，那么会强行重置之后回跳到之前的某个时间点，这种跳跃经常忽略润秒，导致不太适合测量时间间隔。</p><p><strong>单调时钟</strong><br>Linux 的 <code>clock_gettime(CLOCK_MONOTONIC)</code> 和 Java 的 <code>System.nanoTime()</code> 返回单调时钟。单调时钟只会向前，不会出现和墙上时钟的回退现象。</p><p>如果服务器有多个 CPU 那么每个 CPU 可能有多个单独的计时器，由于线程可能被调度到不同的 CPU 中运行，操作系统这个时候会弥补多个计时器的差，但是最好还是对这个弥补保持谨慎态度。</p><p>NTP 同步的时候就不是回退了，而是调整振动频率，然后慢慢和 NTP 服务器同步。</p><h3 id="时钟同步与准确性"><a class="markdownIt-Anchor" href="#时钟同步与准确性"></a> <strong>时钟同步与准确性</strong></h3><p>硬件始终和 NTP 可能会出现一些问题：</p><ul><li>温度会影响计算机中的石英钟，时钟漂移限制了可以达到的最大精度。</li><li>如果时钟和 NTP 服务器差距过大，可能会出现拒绝同步或者强制重置。</li><li>如果和 NTP 链接失败，那么可能会很长一段时间没有意识到错误的配置导致最终同步失败。</li><li>NTP 同步受限于网络环境，由于网络延迟可能产生偏差。</li><li>NTP 服务器配置错误导致偏差。</li><li>闰秒可能会对没有防备的系统出现混乱。</li><li>虚拟机的硬件时钟是被虚拟化的，也会出现偏差。</li><li>如果运行不完全可控的设备上，不能完全相信设备上的时钟。</li></ul><h3 id="依赖同步的时钟"><a class="markdownIt-Anchor" href="#依赖同步的时钟"></a> <strong>依赖同步的时钟</strong></h3><p>和网络问题一样，得假设他们会有问题，但是不同于网络问题，网络问题产生的影响是能够在短期观测出来的，但是时钟的问题不是那么容易观测的，出现的后果可能是隐式的，比如数据库丢失一小部分数据而不是突然的崩溃。比如在多主复制中：</p><p><img src="https://raw.githubusercontent.com/qinggniq/Note/master/GO/MIT6.824/imags/DDIA/8-Trasaction/%E5%90%84%E4%B8%AA%E6%97%B6%E9%92%9F%E4%B8%8D%E4%B8%80%E8%87%B4%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98.png" alt="各个时钟不一致导致的问题"></p><p>写入 <code>x = 1</code> 的时间戳为 42.004 秒，写入 <code>x = 2</code> 虽然是后续发生，时间戳是 42.003 ，所以节点 2 收到两个事件的时候如果根据 LWW（最后写入胜利）的话，那么会将 <code>x = 2</code>的更新丢失。</p><p>这是 LWW 会产生的问题，有的实现在客户端生成时间戳，但是这还是无法解决 LWW 会带来的问题：</p><ul><li>数据库写入可能会奇怪的丢失：后续的写操作不能覆盖之前的写，原因是之前的写时钟过快。这导致了未知的数据被悄悄丢弃，而没有任何报错；</li><li>LWW 无法区分 <strong>快速的连续写操作</strong>和<strong>并发写入</strong>（第五章讲过的并发的定义，就是之前没有因果关系）。需要额外的因果关系跟踪机制（版本向量）来防止因果冲突；</li><li>两个操作可能产生了一个时间戳，需要额外的仲裁值来确定先后关系，但是这样依然无法区分因果关系。</li></ul><p>如果“最新”的定义是<strong>墙上时钟</strong>的话，那么就会引入偏差，即使使用了 NTP 时钟同步，依然可能出现在 100s 的时候发消息，在 99s 的时候收到确认的情况（因为在这段时间里发生了时间同步，导致本地的时钟回退）。</p><p>对于排序来讲，基于递增计数器而不是震荡石英晶体的<strong>逻辑时钟</strong>是更可靠的方式，逻辑时钟不是时间，而是时间发生的相对顺序，相对的墙上时钟和递增时钟都属于物理时钟。</p><p><strong>时钟的置信区间</strong><br>时间不应该被确定为一个固定值，而应该被视为带有置信区间的时间范围。Google Spanner 的 TrueTime API 会明确告诉本地时钟的置信区间，会得到 [不早于，不晚于] 分别代表误差的最大偏差范围。</p><p><strong>全局快照的同步时钟</strong><br>之前提到过的快照隔离级别可以在数据库的某一个状态上不加锁、不违背读写隔离性的前提下高效支持只读事务。</p><p>常见的快照隔离实现需要一个单调递增的事务ID，单机上很好实现，只需要一个原子计数器就行了。</p><p>但是在分布式的情形下，维护一个全局递增的事务ID就十分困难了，事务ID必须反应因果关系，如果事务 B 要读取事务 A 写的值，那么 B 的事务ID必须比 A 的事务ID大，否则快照不一致。</p><p>不能使用墙上时钟作为事务ID，因为时钟不确定性。Google Spanner 使用以下思路来实现跨数据中心的快照隔离。它根据 TrueTime API 返回的时钟置信区间，并基于一下结果来观察：如果 A、B 有两个时钟置信区间，都包含最早和最新可能的时间戳，A = [<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mrow><mi>e</mi><mi>r</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow><mo separator="true">,</mo><mi>A</mi><mrow><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></mrow><annotation encoding="application/x-tex">A{eraliest}, A{lastest}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span></span></span></span>], B = [<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mrow><mi>e</mi><mi>r</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow><mo separator="true">,</mo><mi>B</mi><mrow><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></mrow><annotation encoding="application/x-tex">B{eraliest}, B{lastest}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord"><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span></span></span></span>]，那么如果区间不重叠，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mrow><mi>e</mi><mi>r</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow><mo>&lt;</mo><mi>A</mi><mrow><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow><mo>&lt;</mo><mi>B</mi><mrow><mi>e</mi><mi>r</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow><mo>&lt;</mo><mi>B</mi><mrow><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></mrow><annotation encoding="application/x-tex">A{eraliest}&lt; A{lastest}&lt;B{eraliest} &lt; B{lastest}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord"><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span></span></span></span> 那么可以认定 B 发生在 A 之后。为了确保这个关系，Spanner 在提交读写事务的时候故意等待置信区间的长度。因为Google在每个数据中心部署了一个 GPS 接收器或原子钟，所以 Spanner 的时钟误差范围很小（10ms）。</p><h3 id="进程暂停"><a class="markdownIt-Anchor" href="#进程暂停"></a> <strong>进程暂停</strong></h3><p>除了时钟不精确的问题之外，还有一个在分布式系统中危险使用时钟的例子：假设数据库每个分区只有一个主节点，只有主节点接受写入。那么其他节点如何确信该主节点没有被宣告失败，可以安全地写入呢？</p><p>一个思路是主节点从其他节点获得一个<strong>租约</strong>（lease），类似于一个带超时的锁（GFS中用到）。某个时间只有一个节点可以拿到，有租约的节点就是这段时间的主节点，为了维护主节点的身份，必须在租约到期之前更新租约，如果节点失效，超时的时候租约失败，那么另一个节点到期之后就可以接管。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    requst = getIncomingRequest();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Ensure that the lease always has at least 10 seconds remaining</span></span><br><span class="line">    <span class="keyword">if</span> (lease.expriyTimeMills - System.currentTimeMilliseconds() &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">        lease = lease.renew();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lease.isValid()) &#123;</span><br><span class="line">        process(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码有什么问题？</p><ul><li>它依赖于同步的时钟，租约到期时间由其他服务器所设置，如果两个时钟有延迟，那么可能会有问题；</li><li>如果改为单调时钟，代码假定<code>if</code>判断和<code>process</code>之间的时间很短，所以设置10s的缓冲区来确保在请求的时候不会过期，但是如果程序执行出现了意外的暂停呢？比如在<code>lease.isValid()</code>那里暂停了15s，租约过期，另一个节点已经获得租约，后续代码也不会注意到租约过期，然后继续执行。</li></ul><p>那么什么时候会出现这么长时间的暂停呢？</p><ul><li><em>GC</em>，Java 的 GC 通常会时不时地暂停活动的进程；</li><li><em>虚拟机环境</em>，在虚拟机迁移的时候通常需要暂停虚拟机；</li><li><em>休眠</em>，笔记本电脑休眠；</li><li><em>线程切换</em>，机器负载很高的话，那么可能下次轮到这个进程执行是很晚的时候；</li><li><em>同步磁盘</em>，同步磁盘会引起线程挂起，虽然有些代码没有明显的同步磁盘操作，但是依然可能有意外的引入磁盘IO的操作，比如 Java 的类加载器第一次使用类文件会推迟加载，IO暂停和GC暂停可能同时发生，进一步恶化；</li><li><em>交换区</em>，使用磁盘交换区来虚拟内存，那么内存访问会引起缺页中断然后读磁盘；</li><li><em>SIGSTOP信号</em>，这个信号挂起进程。</li></ul><p>这个问题类似于在单机系统中的多线程代码保证并发安全，但是单机系统共享内存，可以使用锁、信号量、原子计数器、无锁数据结构、阻塞队列来实现，但是分布式系统无法使用。</p><p>所以分布式的系统每个节点必须假定，进程执行过程中的任何时刻都有可能被暂停很长一段时间。</p><p><strong>响应时间保证</strong><br>硬件实时系统可以在硬件层面提供响应时间的保证，可以满足规定的时间约束，比如如果汽车的传感器检测到碰撞，那么肯定不希望进程因为GC而暂停。</p><p>如何保证实时？</p><ul><li>首先是个<strong>实时操作系统</strong>，保证在规定的时间片完成调度；</li><li>库函数必须考虑最坏的执行时间；</li><li>动态分配内存受限或者完全被禁止；</li><li>需要大量的验证。</li></ul><p>开发实时系统比较昂贵。</p><p><strong>调整垃圾回收的影响</strong><br>可以跟踪 GC，然后控制垃圾回收，把 GC 作为一个节点计划内的离线操作，节点 GC 时通知其他节点进行处理请求。</p><p>这种方法的一个变种是只对短期对象执行垃圾回收，然后在其变为长期存活对象之前，采取定期重启的策略避免对长期存活对象的全面回收。</p><h2 id="知识-真相-谎言"><a class="markdownIt-Anchor" href="#知识-真相-谎言"></a> <strong>知识、真相、谎言</strong></h2><h3 id="真相由多数决定"><a class="markdownIt-Anchor" href="#真相由多数决定"></a> <strong>真相由多数决定</strong></h3><p>节点无法根据自身信息来判断自身的状态，所以分布式系统不能依赖单个节点。目前许多分布式算法都依靠法定票数，即在节点间进行投票。任何决策都需要来自多个节点的最小投票数，从而减少对于特定节点的依赖。</p><p>最常见的法定票数是系统节点半数以上，如果某些节点发生故障，那么 quorum 机制可以给使系统继续工作。</p><p><strong>主节点和锁</strong><br>很多情况下，我们需要在系统范围内只能有一个实例，例如：</p><ul><li>只允许一个节点作为数据库分区的主节点，以防止出现脑裂；</li><li>只允许一个事务或客户端持有特定的锁，防止同时写入；</li><li>只允许一个用户使用特定的用户名，从而确保用户名可以唯一标识用户。</li></ul><p>需要注意的是即使一个节点自认为自己的是“唯一的哪一个”（主节点、锁、用户名），但不一定是获得了法定票数的同意，有可能它以前是主节点，但是被其他节点宣布失效了（比如进程暂停）。</p><p>如下图是 HBase 遇到过的问题，它的设计目标是确保存储系统的文件一次只能由一个客户端访问，如果客户端同时试图写入文件，文件就会被破坏。所以客户端写入的时候需要从锁服务中获取访问租约。</p><p><img src="https://raw.githubusercontent.com/qinggniq/Note/master/GO/MIT6.824/imags/DDIA/8-Trasaction/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E4%B8%8D%E6%AD%A3%E7%A1%AE%E5%AE%9E%E7%8E%B0.png" alt="分布式锁的不正确实现"></p><p>这个问题属于前面说的“进程暂停”的情况，持有租约被暂停太久而到期。</p><p><strong>Fencing令牌</strong><br>使用锁和租约机制保证资源的并发访问的时候需要保证过期的旧节点不能影响其它正常部分，可以通过<em>fencing</em>（栅栏）来实现。</p><p>假设每次获取租约或锁的时候锁服务会返回一个<em>fencing令牌</em>，令牌计数每次被分配都会递增，然后客户端每次向存储发送写请求的时候会附加上所持有的<em>fencing令牌</em>。这样就可以防止因为进程暂停带来的问题了。</p><p><img src="https://raw.githubusercontent.com/qinggniq/Note/master/GO/MIT6.824/imags/DDIA/8-Trasaction/%E4%BD%BF%E7%94%A8fencing%E4%BB%A4%E7%89%8C.png" alt="使用fencing令牌"></p><p>Zookeeper 可以使用事务标识 <code>zxid</code> 或节点版本 <code>cversion</code> 来充当 <em>fencing令牌</em>。</p><p>只靠客户端检查状态是不够的，需要资源来进行主动检查，如果资源不支持额外的令牌检查，可以通过文件名内嵌令牌信息的方式来检查。</p><p>服务器不能假定客户端都是正常的。</p><h3 id="拜占庭故障"><a class="markdownIt-Anchor" href="#拜占庭故障"></a> <strong>拜占庭故障</strong></h3><p><em>fencing令牌</em>可以检测并阻止那些无意的误操作，但是如果一个节点故意破坏系统，在消息的时候伪造令牌又如何呢？</p><p>本书总是假设节点虽然不可靠但是一定是诚实的：</p><blockquote><p>它们尽管运行很慢或者由于故障而无法响应，或者状态已经过期，但一旦响应，则一定是完全基于其所知的全部信息和实现协议好的行为准则，响应代表了其所知的“真相”。</p></blockquote><p>如果节点存在撒谎的情况，那么分布式系统的处理的难度就上了一个台阶。这种行为被称为<strong>拜占庭错误</strong>。</p><p>如果在某个系统中即使发生部分节点故障，甚至不遵从协议，或者恶意攻击、干扰网络，仍然可以正常运行，那么我们称之为<strong>拜占庭式容错系统</strong>。</p><ul><li>在航空航天领域，辐射可能造成内存或 CPU 的故障，以不可预知的方式响应其他节点，系统下线十分昂贵，所以需要飞机控制系统容忍拜占庭式错误；</li><li>比特币。</li></ul><p>Web里面可能有恶意客户端行为，这时需要安全机制来保证，软件的 bug 可以被认为是拜占庭错误，但是如果将软件部署到所有节点上，那么即使拜占庭式错误也无法解决问题。大多数拜占庭容错算法要求系统超过三分之二的节点要功能正常。</p><p>传统的安全措施如认证、访问控制、加密、防火墙等仍然是防范攻击的主要保护措施。</p><p><strong>弱的谎言形式</strong><br>尽管假设节点是诚实的，但是还是需要采取一些措施来防范那些不是那么恶意的“谎言”，比如硬件造成的无效信息、软件BUG、配置错误。</p><ul><li>由于硬件、操作系统、驱动程序、路由器造成的错误导致网络数据包有时出现损坏，通常可以借助 TCP/UDP 中内置的数据包校验和来发现这些问题，有时无法奏效，可以通过应用层的校验和来防范；</li><li>公众开放的接口必须进行参数检查；</li><li>NTP 最好配置多个时间服务器，使得多个服务器就一定时间范围达成一致。</li></ul><h3 id="理论系统模型与现实"><a class="markdownIt-Anchor" href="#理论系统模型与现实"></a> <strong>理论系统模型与现实</strong></h3><p>目前分布式系统方面已经有很多不错的算法，这些算法要容忍本章讨论的各种故障。</p><p>算法的实现不能过分依赖于特定的硬件和软件配置，这需要我们对预习的系统错误进行形式化描述，我们通过定义一些系统模型来形式化描述算法的前提条件。</p><p>关于计时方面，有常见的三种模型：</p><p><em>同步模型</em><br>同步模型假设有上界的网络延时，有上界的进程暂停和有上界的时钟误差，大多数系统并非同步模型，因为无限延迟和暂停确实可能发生。</p><p><em>部分同步模型</em><br>意味着系统绝大多数情况下像一个同步系统运行，但是有时会出现超出网络延迟，进程暂停和时钟漂移的预期上界。</p><p><em>异步模型</em><br>算法不会对时机做任何假设，甚至里面没有时钟（也没有超时机制）。</p><p>关于节点时效方面，有常见的三种模型：</p><p><em>崩溃-中止模型</em><br>此模型下节点只会遭遇一种故障，即遭遇系统崩溃。节点突然失去响应，然后永远消失无法恢复。</p><p><em>崩溃-恢复模型</em><br>节点可能在任何时候发生崩溃，且会在一段（未知）时间之后得到恢复并再次响应，节点中的持久性存储数据在崩溃中得以保存，而内存状态可能消失。</p><p><em>拜占庭失效模型</em><br>节点可能发生任何事情，包括作弊和欺骗其他节点。</p><p><strong>算法的正确性</strong><br>定义算法的正确性，我们可以描述它的属性信息。比如之前的<em>fencing令牌</em>生成算法要求算法具有一下属性：</p><ul><li><em>唯一性</em>：两个令牌不能获得一样的值</li><li><em>单调递增</em>：如果请求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>返回了令牌<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">t{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord"><span class="mord mathdefault">x</span></span></span></span></span>，请求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>返回了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">t{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>之前完成，那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>x</mi><mo>&lt;</mo><mi>t</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">t{x} &lt; t{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65418em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">t</span><span class="mord"><span class="mord mathdefault">x</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></span></li><li><em>可用性</em>：请求令牌的节点如果不发生崩溃则一定会收到响应</li></ul><p>如果针对某个系统模型的算法在各种情况下都能满足定义好的属性请求，那么我们称这个算法是正确的。</p><p><strong>安全性和活性</strong><br>在上面的例子中，唯一性和单调递增性属于安全性，而可用性属于活性。</p><blockquote><p>活性的定义中一般包括暗示“最终”一词。</p></blockquote><p>安全性可以理解为<strong>没有发生意外</strong>，活性可以理解为<strong>预期的事最终一定会发生</strong>，具体的定义如下：</p><ul><li>如果违反了安全属性，我们可以明确的执行发生的时间点，一旦违反，违规行为无法撤销，破坏已经实际发生；</li><li>活性则反过来：可能无法明确一个时间点，但总是希望未来某个时间点可以满足要求。</li></ul><p>区分安全性和活性好处是可以简化处理一些具有挑战性的系统模型，对于分布式算法，要求所有可能的系统模型下，都必须符合安全属性，也就是说如果节点崩溃，网络中断，算法确保不会返回错误的结果。</p><p>对于活性，则存在一些必要条件才能满足。比如只有在大多数节点没有崩溃，以及网络最终可以恢复的前提下，我们才能最终收到响应。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发者的核心任务是构建可靠的系统，即使系统面临着各种出错的可能，也需要完成预定的工作。&lt;/p&gt;
&lt;p&gt;本章对分布式系统可能出现的故障做了一个全面的、近乎悲观的总结，故障可能来自：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;网络问题&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;时钟和时序问题&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;并讨论这些问题的可控程度，接下来会探讨如何认清分布式系统的状态本质，并以此来评估发生的各种故障。&lt;/p&gt;
    
    </summary>
    
    
      <category term="分布式" scheme="https://qinggniq.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="DDIA" scheme="https://qinggniq.com/tags/DDIA/"/>
    
  </entry>
  
  <entry>
    <title>DDIA读书笔记——第七章-事务</title>
    <link href="https://qinggniq.com/2019/11/05/DDIA%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%83%E7%AB%A0-%E4%BA%8B%E5%8A%A1/"/>
    <id>https://qinggniq.com/2019/11/05/DDIA读书笔记——第七章-事务/</id>
    <published>2019-11-05T14:47:05.000Z</published>
    <updated>2019-11-30T06:44:53.669Z</updated>
    
    <content type="html"><![CDATA[<p>在一个苛刻的数据存储环境中，可能会出现很多出错的情况。</p><ul><li>数据库软件失效；</li><li>应用程序随时崩溃；</li><li>应用和数据库节点通信失效、数据库之间的通信失效</li><li>多个客户端同时写入，导致数据覆盖；</li><li>客户端可能读到无意义的、部分更新的数据；</li><li>客户端之前由于边界条件竞争引入的各种奇怪问题。</li></ul><a id="more"></a><p>这些问题都是需要解决的，然而完善的容错机制需要大量的工作，要仔细考虑各种情况，并进行完备的测试。</p><p><strong>事务</strong>一直是简化这些问题的首选措施。事务将应用程序的多个读、写操作捆绑在一起成为一个逻辑单元。即一组操作是一个整体，事务提交要么成功（提交），要么失败（中止或回滚）。这样失败之后客户端可以不断重试而不必担心部分失败的情况。</p><p>虽然事务很好，但是它的代价又是什么呢？一个应用需不需要事务由什么来决定呢？</p><h2 id="深入理解事务"><a class="markdownIt-Anchor" href="#深入理解事务"></a> <strong>深入理解事务</strong></h2><h3 id="acid的含义"><a class="markdownIt-Anchor" href="#acid的含义"></a> <strong>ACID</strong>的含义</h3><p>各个数据库对于<strong>ACID</strong>有着不同的含义，我们需要的是搞清楚原子性（A）、一致性（C）、隔离性（I）、持久性（D）的准确定义。</p><p><strong>原子性</strong><br>原子性在<strong>多线程编程</strong>和<strong>数据库</strong>中都有这个名词，前者指的是：</p><blockquote><p>如果某个线程正在执行原子操作，那么其他线程无法看到改操作的中间结果。它只能处于操作之前和之后的状态，而不是两者之间的状态。</p></blockquote><p>而数据库中的原子性与并发操作无关，反而是隔离性与并发操作有关。数据库中的原子性描述了客户端发起一个包含多个写操作的请求时可能发生的情况。如果写入操作的过程中发生的意外情况而导致事务没法最终提交的时候，事务会中止，并且那些部分完成的更改也必须被丢弃。</p><p>如果没有原子性保证，那么更新操作中间发生错误的时候需要知道哪些已经失效哪些没有失效，这个过程十分麻烦。原子性的保证让应用程序可以安全的重试。因此数据库中的原子性所定义的特征是：</p><blockquote><p>在出错的时候中止事务，并将部分完成的写入全部丢弃。</p></blockquote><p><strong>一致性</strong><br>一致性在不同场景有不同的含义：</p><ul><li>在<strong>数据复制</strong>章节中讨论了副本一致性和异步复制模型时引出了最终一致性问题；</li><li>一致性哈希是某些系统用于动态分区再平衡的方法；</li><li>CAP理论中，一致性用来表示线性化问题；</li><li>ACID中，一致性主要指数据库处于应用程序期待的”预期状态“。</li></ul><p>所以在数据库中，<strong>一致性指对数据有特定的预期状态，任何数据的更改必须满足这些状态约束</strong>。比如在银行系统中，贷款额和借款余额应该保持平衡，这些约束主要由应用层来保证，数据库是很难检测并阻止这些操作的（数据库可以对某些数据类型的数据进行恒等性检查，比如外键或唯一性约束，但是通常主要靠应用程序来定义数据的有效/无效状态，数据库主要用于存储）。</p><p>原子性、隔离性、持久性是数据库自身的属性，而ACID中的一致性更多的是应用层的属性。应用程序可能通过数据库提供的原子性、隔离性来达到一致性，但是一致性本身并不源自于数据库。因此字母 C 不应该属于 ACID。</p><p><strong>隔离性</strong><br>大多数数据库允许客户端同时访问数据库。如果访问相同的数据，那么可能会出现问题。</p><p>下图是一个计数器例子，由于竞态条件，最终结果不正确。</p><p><img src="https://raw.githubusercontent.com/qinggniq/Note/master/GO/MIT6.824/imags/DDIA/8-Trasaction/DDIA-%E4%BA%8B%E5%8A%A1-%E8%AE%A1%E6%95%B0%E5%99%A8.png" alt="计数器的bug"></p><p>ACID语义中的隔离性意味着并发执行的多个事务相互隔离，它们不能交叉。经典的数据库教材把隔离性定义为可串行化（Linerable），这意味着可以假装它是数据库上运行的唯一事务。虽然实际上他们可能同时运行，但是数据库提交的时候，其结果和串行执行完全相同。</p><p>但是在实践中很少使用串行化隔离。</p><p><strong>持久化</strong><br>数据库的本质是提供一个安全可靠的地方来存储数据而不用担心数据丢失，持久性就是这样的承诺，它保证一旦事务提交成功，即使存在硬件故障或者数据库崩溃，事务所写入的任何数据也不会丢失。</p><p>在单点数据库中，持久性通常意味着数据已经写入非易失性存储了，但在写入的执行过程中通常还涉及到预写日志（WAL）等，这样磁盘数据损坏还可以进行修复。对于支持远程复制的数据库，持久性意味着数据已经被大多数节点成功复制。</p><h3 id="单对象和多对象事务操作single-operation-transaction-multi-operation-transaction"><a class="markdownIt-Anchor" href="#单对象和多对象事务操作single-operation-transaction-multi-operation-transaction"></a> <strong>单对象和多对象事务操作</strong>（single-operation transaction &amp; multi-operation transaction）</h3><p>之前对于原子性和隔离性的定义主要是针对客户端在同一事务中包含多个写操作时提供的保证。这些假定在一个事务中修改多个对象。这种多对象事务的目的通常是为了在多个数据对象之前保持同步。</p><p>多对象事务要求确定知道事务包含了哪些读写操作，在关系型数据库里面客户端和数据库服务器建立 TCP 网络连接，所以对特定的连接，SQL 语句 BEGIN TRANSACTION 和 COMMIT 之间的所有操作都属于同一个事务。</p><p>而许多非关系数据库则不会将这些操作组合在一起。即使他们可能支持多对象 API （例如，键-值存储的<em>multi-put</em> API 可以在一个操作中更新多个键），单并不意味着具有事务语义，例如可能出现某个键更新成功了而其他则发生了失败，最后结果是数据库处于部分更新的状态。</p><p><strong>单对象写入</strong><br>原子性和隔离性也适用于单个对象的更新。例如向数据库写入 20KB 的 JSON 文档：</p><ul><li>如果发送了第一个 10KB 后网络连接中断，数据库是否只存储了无法完整解析的 10KB JSON片段呢？</li><li>如果数据库在覆盖磁盘现有数据时发生电源故障，最终是否是新旧值混在一起？</li><li>如果另一个客户端在写入的时候中读取该文档，是否会看到部分更新的文档内容？</li></ul><p>存储引擎必备的就是在单节点中提供原子性和隔离性，比如宕机的时候使用日志恢复来实现原子性，对每个对象使用加锁的方式实现隔离性。</p><p>有些数据库提供了<strong>原子自增</strong>或<strong>Compare-and-set</strong>操作。这些单对象操作可以防止多个客户端并发修改一个对象时的更新丢失问题，但是它们不是通常意义上的事务，（通常意义上的事务指多个操作聚合为逻辑单元）。</p><p><strong>多对象事务的必要性</strong><br>涉及分区的时候多对象事务会带来性能的极大损耗。</p><ul><li>关系型数据库里面涉及多表查询的时候需要多对象事务。</li><li>对于文档数据模型，也需要join，所以更新需要更新多个表，还是需要多对象事务。</li><li>对于带二级索引的数据库，每次更改值的时候都需要更新索引。</li></ul><p><strong>处理错误和终止</strong><br>事物的一个关键特性是，如果发生了意外，所有操作被中止，之后可以安全重试。支持安全的重试机制才是中止流程的重点，但是重试有下列的问题</p><ul><li>如果事务已经执行成功，但是返回结果丢失，那么重试机制会导致重复执行，这是需要额外的应用级重复数据删除机制（银行系统）；</li><li>如果错误是由于系统操负载所致，重试将会使情况更糟；</li><li>如果出现了永久性的故障，重试没有意义；</li><li>如果在数据库之外，事务会发生其他副作用，比如发邮件，重试就不太合适。可以使用“两阶段提交的方式”；</li><li>如果客户端在重试的过程中发生失败，没有其他人负责重试，那么那些待写入的数据可能因此而丢失。</li></ul><h2 id="弱隔离级别"><a class="markdownIt-Anchor" href="#弱隔离级别"></a> <strong>弱隔离级别</strong></h2><p><strong>事务隔离</strong>主要用来对应用开发人员隐藏各种并发问题。可串行化意味着并行事务的执行结果与串行执行结果一致。</p><p>但是串行化隔离级别带来的性能损失过大，所以一些数据库选择实现<strong>弱隔离级别</strong>。它可能带来难以琢磨的隐患。下面介绍几个实际常用的弱隔离级别，讨论可能发生的竞态条件，可以帮助我们判断自己的应用适合什么隔离级别。</p><h3 id="读-提交"><a class="markdownIt-Anchor" href="#读-提交"></a> <strong>读-提交</strong></h3><p>最基本的事务隔离级别，提供了两个保证：</p><ul><li>读数据库的时候只能看到已经成功提交的数据（防止“脏读”）；</li><li>写数据库的时候只会覆盖已经成功提交的数据（防止“脏写”）；</li></ul><p><strong>防止脏读</strong></p><blockquote><p>如果一个事务可以看到另一个事务没有提交的数据，那么就是<strong>脏读</strong>。</p></blockquote><p>有以下需求的时候，需要防止脏读：</p><ul><li>事务需要更新多个对象，脏读意味着另一个事务可能会看到部分更新，而不是全部更新，这样可能会造成客户的困惑；</li><li>如果事务中止，那么另一个事务可能看到的是之后会被回滚的数据，这样可能造成不可预料的后果。</li></ul><p><strong>防止脏写</strong></p><blockquote><p>如果一个事务的写入可以覆盖另一个事务未提交的写入数据，那么就是<strong>脏写</strong>。</p></blockquote><p>读-提交的隔离级别通过推迟第二个写操作来避免脏写。防止脏写可以避免以下的并发问题：</p><ul><li>如果事务需要更新多个对象，脏写会带来不可预料的后果；</li><li>读-提交隔离不能解决计数器竞争的问题，就是 A 读了数字 N， B 也读了数字 N ，然后各自加一，但是最终写入的却是 N + 1，那个例子确实满足了读-提交保证的特性，但是却产生了非预期的结果。</li></ul><p><strong>读-提交的实现</strong><br>数据库一般使用行级锁来防止脏写：当事务想要修改某个对象，它必须获得对象的锁，持有锁到事务提交。</p><p>数据库防止脏读有两种方法：</p><ul><li>和防止脏读一样用一个行级锁，但是对于长时间的写操作，可能会有很多读操作等待。</li><li>维护两个版本的数据，事务提交前，其他读操作读旧值，事务提交后切换为新值。</li></ul><h3 id="快照级别隔离于可重复读"><a class="markdownIt-Anchor" href="#快照级别隔离于可重复读"></a> <strong>快照级别隔离于可重复读</strong></h3><p>在使用读-提交的隔离级别的时候其他场景会导致并发错误，比如在从账号 1 转账到账号 2 的时候 A 可能发现账户 2 的余额减少了而账户 1 的余额没有增加，虽然它们符合读-提交提供的保证，但是出现了非预期状态。</p><p>这种状态叫做<strong>不可重复读取</strong>（nonreplication read）或<strong>读倾斜</strong>（read skew）,如果 A 在这个转账者事务未提交的时候再次读取账户 1 的余额，可能会读取到不同的值，这种现象也叫作<strong>幻读</strong>。这种现象在有些情形下是不可以接受的：</p><ul><li><em>备份场景</em>：备份任务需要备份整个数据库，在备份过程中可以继续执行写操作，所以备份下来的镜像里面可能会同时出现旧版本数据和新版本数据。如果数据库根据这样的数据恢复，那么可能导致永久的数据库不一致。</li><li><em>分析查询与完整性检查场景</em>：有些查询几乎会扫描大半个数据库，如果这些查询在不同时间点观察数据库，可能会获得毫无意义的结果。</li></ul><p><strong>快照隔离级别</strong>是上述问题的解决手段，它保证每个事务只能看到特定时间点的旧数据。</p><p><strong>快照隔离基本的实现</strong><br>和实现读-提交的实现方式一样，在写的时候加一个写锁来防止脏写，但是读操作不用加读锁，不会影响其它事务的写操作，而且写操作也不会影响其它事物的读操作。所以快照级别隔离可以在处理写操作的同时执行长时间的读操作。</p><p>为了实现快照基本隔离，数据库采用了一种类似于读-提交中防止脏读的机制。考虑到多个事务可能会在不同时间点查看数据库状态，所以<strong>数据库机制保留了多个对象的不同提交版本</strong>，这种技术也叫作<strong>多版本并发控制</strong>（MVCC）。</p><p><img src="https://raw.githubusercontent.com/qinggniq/Note/master/GO/MIT6.824/imags/DDIA/8-Trasaction/%E5%88%A9%E7%94%A8%E5%A4%9A%E7%89%88%E6%9C%AC%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%BF%AB%E7%85%A7%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.png" alt="利用多版本技术实现快照隔离级别"><br><strong>一致性快照的可见性原则</strong></p><ol><li>每个事务开始时列出当前进行的其他事务，然后忽略这些事务的部分写入，不管之后这些写入有没有可能被提交；</li><li>所有中止事务所做的修改不可见；</li><li>较晚事务的修改不可见；</li><li>除此之外，其他事务的修改可见。</li></ol><p>也就是说，以下的数据可见：</p><ol><li>事务开始的时候，创建对象的事务完成了提交；</li><li>对象没有被标记为删除，或者被标记了但是没有被提交。</li></ol><p><strong>索引和快照隔离级别</strong><br>那么多版本数据库怎么支持索引呢？一种办法是索引直接指向对象的所有版本然后想办法过滤掉当前事务不可见的版本，垃圾回收的时候也要删除旧版本对应的索引条目。</p><p>还有一种实现方式是在B-Tree存储结构的前提下修改的时候不直接修改，而是总是创建一个新的修改版本，拷贝必要内容然后让节点指向父亲节点。</p><h3 id="防止更新丢失"><a class="markdownIt-Anchor" href="#防止更新丢失"></a> <strong>防止更新丢失</strong></h3><p>之前的案例都是考虑只读事务遇到并发写的时候会看到什么，而没有考虑两个写事务并发。</p><p>并发写可能会带来<strong>更新丢失问题</strong>。更新丢失问题一般发生在”读-修改-写回“的场景中，比如：</p><ul><li>之前提到的计数器递增的例子；</li><li>对某个复杂对象的一部分进行修改，比如对JSON文档的内容进行修改；</li><li>两个用户同时编辑wiki页面。</li></ul><p>解决方案：<br><strong>原子写操作</strong><br>有些数据库提供了原子写操作，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> counters <span class="keyword">SET</span> <span class="keyword">value</span> = <span class="keyword">value</span> + <span class="number">1</span> <span class="keyword">WHERE</span> <span class="keyword">key</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这条语句在很多数据库都是安全的。如果原子操作可行，那么它一般是最佳的方式。</p><p>原子操作一般使用独占锁的方式实现，其他事务在原子操作提交前不能读写它。还有一种实现方式是把所有的原子操作放到单线程上面执行。</p><p>一些ORM框架可能会产生一些不是“读-修改-写回”的代码，导致不能使用数据库的原子操作，你需要知道这件事情。</p><p><strong>显式加锁</strong><br>有些同步写不能使用原子操作，这个时候可以使用显式的行锁来执行，比如<code>FOR UPDATE</code>语句。</p><p><strong>自动检测更新丢失</strong><br>上面两种方法都是强制“读-修改-写回”操作序列串行的方式实现。还有一种方法是让操作并发执行，如果事务管理器检测到了更新丢失风险，那么就终止当前事务，回退到“读-修改-写回”的方式。</p><p><strong>原子比较和设置</strong><br>只有上次读取的数据没有发生变化才允许更新；如果发生了变化，那么回退到“读-修改-写回”的方式。</p><p><strong>冲突解决和复制</strong><br>在数据复制中，涉及多个节点的异步复制，不同节点可能并发修改数据，需要采取措施来防止更新丢失。</p><p>加锁和原子修改都有一个前提——只有一个最新的数据副本。但是对于多主节点和无主节点复制里面，复制一般是异步复制，可能会有多个最新的数据副本。这个时候加锁和原子比较将不再适用（为啥？）。</p><p>解决方法和之前提到的差不多，时间戳、写入合并等方式，注意的是可交换操作比如加法，在不同顺序执行也能得到相同的结果，在多副本的情况下也能工作。</p><h3 id="写倾斜和幻读"><a class="markdownIt-Anchor" href="#写倾斜和幻读"></a> <strong>写倾斜和幻读</strong></h3><p>前面介绍了事务同时写入同一对象的时候可能会发生的问题，也就是<strong>脏写</strong>和<strong>更新丢失</strong>。为了避免这些问题需要借助数据库中的一些内置机制，比如手动加锁和原子操作等。但是并发写不仅仅只会引发这些问题。</p><p>比如医生值班系统，必须有至少一个医生值班，Alice 和 Bob 都想请假，它们同时点开了调班按钮。如下图所示</p><p><img src="https://raw.githubusercontent.com/qinggniq/Note/master/GO/MIT6.824/imags/DDIA/8-Trasaction/%E7%94%B1%E4%BA%8E%E5%86%99%E5%80%BE%E6%96%9C%E5%AF%BC%E8%87%B4%E7%9A%84bug.png" alt="7-8由于写倾斜导致应用程序出现错误的实例"></p><p>数据库正在使用快照隔离，所以他们都会同时读到有两个医生正在值班，自己和另一个人，Alice 更新自己为离开，Bob 也更新自己为离开，两个事务都提交成功，但是这样违背了业务需求。</p><p><strong>定义写倾斜</strong></p><blockquote><p>如果两个事务读取的是相同的一组对象，然后更新一部分：不同的事务可能更新不同的对象，则可能发生<strong>写倾斜</strong>；不同的事务更新同一个对象，则可能发生<strong>脏写</strong>或<strong>更新丢失</strong>。</p></blockquote><p>之前解决防止更新丢失的方式在解决写倾斜的时候有很多限制：</p><ul><li>涉及多个对象，单对象的原子操作无用；</li><li>基于快照级别隔离来实现更新丢失自动检测也有问题：目前所有的数据库实现的快照化隔离级别都不支持检测写倾斜的问题。自动防止写倾斜要求真正的<strong>可串行化隔离</strong>；</li><li>大多数数据库不支持类似于医生值班的多对象类型约束；</li><li>如果不能使用可串行化级别隔离，那么一个折中的选择是对事务依赖的行为显式加锁：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> doctors</span><br><span class="line">    <span class="keyword">WHERE</span> on_call = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">AND</span> shift_id = <span class="number">1234</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> doctors</span><br><span class="line">    <span class="keyword">SET</span> on_call = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Alice'</span></span><br><span class="line">    <span class="keyword">AND</span> shift_id = <span class="number">1234</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p><strong>更多写倾斜的例子</strong><br><em>会议室预定系统</em><br>要求同一时间一个会议室不能被预定两次，那么预定的时候先要检查有没有已有的预定，没有再去提交预定。然而快照级别隔离无法阻止并发用户预定同一个会议室。</p><p><em>多人游戏</em><br>多人玩棋类游戏，锁无法阻止两个玩家将不同的数字移动到一个位置上。</p><p><em>声明一个用户名</em><br>两个人同时申请一个用户名，如果按照“读-修改-写回”的方式先检查有没有这个用户名，然后提交新用户名，快照级别隔离无法阻止并发的同一个用户名。可能使用唯一性约束比较简单。</p><p><strong>为什么会发生写倾斜</strong><br>写倾斜的例子一般遵循这样的操作模式：</p><ol><li>输入一些匹配条件进行查询；</li><li>根据查询的结果，应用层代码进行接下来的操作；</li><li>如果决定继续执行，那么提交写。</li></ol><p>而第三步提交的写入可能会改变第二步所依据的条件，第一步执行的查询在第三步执行之后可能会产生和最初的结果不一样。</p><blockquote><p>这种在一个事务中的写入改变了另一个事务查询结果的现象称为<strong>幻读</strong>。</p></blockquote><p>快照级别隔离只能避免只读查询时候的幻读，但是之前讨论的读-写事务，不能解决写倾斜问题。</p><p><strong>实体化冲突</strong><br>之前说的一种解决方法是对依赖的行为加锁，但是如果问题是查询结果中为空，没有加锁的对象，那么这个方法就不奏效了。</p><p>可以通过人为引入可锁的对象。这种方法称为<strong>实体化冲突</strong>，它把幻读问题转化为针对数据库中一组具有实体行的锁冲突问题。</p><h2 id="串行化"><a class="markdownIt-Anchor" href="#串行化"></a> <strong>串行化</strong></h2><p>之前讨论过很多竞态条件，虽然读-提交和快照隔离级别隔离可以解决防止一部分，但是对于写倾斜和幻读的问题还是无法解决。还有一些问题需要面对：</p><ul><li>隔离级别往往难以理解，而且不同数据库的实现不一致；</li><li>如果检查应用层代码，往往很难判断它们在特定隔离级别是否安全。</li><li>缺乏工具去检测竞争的情况。</li></ul><p>这些问题都可以通过一个方法解决：<strong>采用可串行化隔离</strong>。</p><blockquote><p>可串行化隔离通常被认为是最强的隔离级别。它保证即使事务并行执行，但最终执行的结果与串行执行的结果一致。</p></blockquote><p>实现可串行化隔离往往从下列三个技术中选择一个：</p><ul><li>使事务真正按照串行顺序执行；</li><li>两阶段锁定，最常用的方法；</li><li>乐观并发控制技术，例如可串行化的快照隔离级别。</li></ul><p><strong>实际串行执行</strong><br>解决并发的最好方法就是避免并发：在一个线程上顺序执行每个事务。这样直观的方法只有到2007年之后才渐渐被人使用，有两方面的原因：</p><ul><li><em>内存越来越便宜</em>：现在许多应用都可以把所有的数据集放在内存里面，那么事务的执行速度比等待磁盘IO快很多。</li><li><em>OLTP类型的事务通常执行很快</em>：通常情况下执行较长的分析查询往往是只读的，可以在快照隔离基本下并行运行。</li></ul><p>VoltDB、Redis、Datomic使用串行方式执行事务。它避免了锁开销，有时候比并行程序执行更快。</p><p><strong>采用存储过程封装事务</strong><br>往往人类交互的时间比事务执行时间长的多得多，那么希望一个事务作为一个整体去执行。单线程串行执行的系统往往不支持交互式的多语句事务。</p><p><strong>存储过程的优缺点</strong></p><ul><li>每个厂商都有自己的存储过程语言，难用；</li><li>调试困难，运行代码难以管理；</li><li>设计失败的存储过程往往带来更大的性能开销，因为数据库往往被多个应用服务器共享。</li></ul><p>所以现在的新的存储过程放弃了PL/SQL，而是使用了现有的通用编程语言，如Redis使用Lua。</p><p><strong>分区</strong><br>跨分区的事务比较困难，对于复杂的，比如带有二级索引的数据需要大量的跨区协调，因此不太合适。</p><h3 id="两阶段加锁"><a class="markdownIt-Anchor" href="#两阶段加锁"></a> <strong>两阶段加锁</strong></h3><p>之前提到可以使用加锁的方式防止脏写，两阶段加锁的方式类似，但是锁的强制性更高。</p><ul><li>如果 A 读取了某个对象，B 想要写入该对象，那么 B 得等到 A 提交或中止才能执行写入，确保在 A 执行过程中 B 不会修改对象；</li><li>如果 A 已经修改了对象，而 B 想要读取对象，那么 B 得等到 A 提交或中止了才能读取。所以对于 2PL，不会出现读到旧值的情况，也就是幻读。</li></ul><p>之前的快照隔离级别是读写互不干扰，现在是读取和修改会产生互斥。</p><p><strong>实现两阶段加锁</strong><br>MySQL（InnoDB）和SQL Server里面都用两阶段加锁实现了串行化隔离级别。</p><p>数据库的每个对象都有一个读写锁来隔离读写操作，即锁可以处于共享模式或独占模式。</p><ul><li>事务用共享模式获得锁来读取对象。多个事务可以同时获得对象的共享锁，如果一个事务获得了独占锁，那么其他所有事务必须等待；</li><li>事务必须获得独占锁才能修改对象；</li><li>事务可以读取对象后，然后将共享锁升级为独占锁；</li><li>事务获得锁之后一直持有锁知道事务提交。</li></ul><p>这种锁机制可能导致死锁现象的发生。</p><p><strong>2PL 的性能</strong><br>性能是两阶段加锁的主要缺点。一部分原因是锁的获取和锁的释放本身的开销，但更重要的是降低了事务的并发性。一旦两个事务试图做任何可能导致竞态条件的事情，那么其中一个必须等待另一个事务的提交。</p><p>在 2PL 中一个事务的提交时间如果不确定的话，那么可能会导致许多事务提交时间的不确定，这样会使系统的其他部分停了下来。而且发生死锁的话，死锁后的重试也会导致性能下降。</p><p><strong>谓词锁</strong><br>谓词锁和之前提到的独占/贡共享锁的区别在于，谓词锁加锁的不是特定的对象，而是作用于某些满足搜索条件的所有查询对象。</p><ul><li>如果 A 想读取某些满足匹配条件的对象，它必须以共享模式获得查询条件的谓词锁，如果其他事务占有任何满足查询条件的对象，那么必须等到它们提交了才能执行查询；</li><li>如果 A 想插入、更新、删除任何对象，必须检查所有新值或旧值是否和现有的任何谓词锁匹配。如果某个事务持有这样的谓词锁，那么必须等到它们提交了才能继续。</li></ul><p>谓词锁的特别之处在于谓词锁可以保护那些还不存在，但是可能会马上被写入的对象（幻读）。谓词锁和 2PL 结合使用可以真正实现可串行化。</p><p><strong>索引区间锁</strong><br>是谓词锁的简化版，去除了过多的限制。</p><h3 id="可串行化的快照隔离"><a class="markdownIt-Anchor" href="#可串行化的快照隔离"></a> <strong>可串行化的快照隔离</strong></h3><p>前面说的方法都会给性能带来比较大的损失。而2008年提出的<strong>可串行化的快照隔离级别</strong>它既可以提供串行化保证，而且性能相对于快照隔离级别损失很小。</p><p><strong>悲观与乐观的并发控制</strong><br>两阶段加锁是一种典型的悲观并发控制，也就是说，如果某些操作可能出错，那么就直接放弃，采用等待的方式直到绝对安全。</p><p>相比之下，可串行化的快照隔离是一种乐观并发控制。如果可能发生潜在冲突，事务会继续执行而不是中止；当事务提交的时候，数据库会检测是否发生了冲突，如果发生了冲突，中止事务并接下来重试。</p><p>乐观并发控制是一个古老的想法，如果冲突很多，则性能不佳，大量的事务必须中止，如果系统已经接近其最大吞吐量，反复重试会使系统性能变得更差。</p><p>乐观并发控制还可以通过可交换的原子操作来减少一些竞争情况。可串行化快照隔离是在快照隔离的基础上的，并在其基础上增加的相关算法检测写入之间的串行化冲突而决定中止哪些事务。</p><p><strong>基于过期的条件做决定</strong><br>在之前讨论写倾斜的时候，介绍过这样的使用场景，事务首先查询某些数据，然后根据这些数据决定接下来的行为，但是在进行这个行为的时候可能其他事务已经修改了之前依据的数据。比如医生值班的问题。</p><p>在应用程序执行查询的时候，数据库本身无法预知应用层逻辑如何处理查出来的数据，那么为了安全起见，所有对查询结果的修改都应该使写事务失效。那么数据库如何得知查询结果是否被修改了呢？可以分为一下两种情况：</p><ul><li>读取是否作用于一个（即将）过期的MVCC对象上；</li><li>检查写入是否影响将要完成的读取；</li></ul><p><strong>检测是否读取了过期的MVCC对象</strong><br>在快照隔离级别时，事务从MVCC数据库一致性快照读取的时候，会忽略那些在创建快照时尚未提交的事务写入。比如下图，</p><p><img src="https://raw.githubusercontent.com/qinggniq/Note/master/GO/MIT6.824/imags/DDIA/8-Trasaction/%E6%A3%80%E6%B5%8B%E4%BA%8B%E5%8A%A1%E6%98%AF%E5%90%A6%E4%BB%8EMVCC%E5%BF%AB%E7%85%A7%E4%B8%AD%E8%AF%BB%E5%8F%96%E4%BA%86%E6%97%A7%E5%80%BC.png" alt="7-10检测事务是否从MVCC快照中读取了旧值"></p><p>事务 42 未提交，所以Alice查询的 <code>on_call</code> 的值是 <code>true</code> ，当事务 43 提交的时候，42 已经完成了提交，意思是之前快照读取时忽略的写入已经生效，并且直接导致事务 43 做决定的前提已经不再成立。</p><p>为了防止这种异常，数据库需要追踪那么由于 MVCC 可见性规则而被忽略的写操作，当事务提交的时候数据库会检查是否存在一些当初被忽略的写操作是否已经完成了提交，如果是则中止事务。</p><p><strong>检测写是否影响了之前的读</strong><br>第二种情况是，在一个事务读取了数据之后，另一个事务修改了数据，如下图：</p><p><img src="https://raw.githubusercontent.com/qinggniq/Note/master/GO/MIT6.824/imags/DDIA/8-Trasaction/%E6%A3%80%E6%B5%8B%E4%BA%8B%E5%8A%A1%E6%98%AF%E5%90%A6%E4%BF%AE%E6%94%B9%E4%BA%86%E5%8F%A6%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C.png" alt="7-11在可串行化的快照隔离中，检测事务是否修改了另一个事务的查询结果">)</p><p>在“两阶段加锁”中，有<strong>索引区间锁</strong>它可以锁定与某个查询条件匹配的所有行，这里使用了相似的技术，区别在于：SSI锁不会阻塞其他事务。</p><p>在上图中，事务 42 和事务 43 都在查询轮班 1234 期间的值班医生。如果在 <code>shift_id</code> 上建立了索引，数据库可以根据索引条目 1234 来记录事务 42 和 43 都查询了相同的结果。如果没有索引，那么可以在表级别跟踪这些信息。</p><p>当另一个事务尝试修改的时候，它会先检查索引，确认是否有其他事务之前读取过它。过程类似于获取写锁，但是这个操作不会影响读操作，而是在读事务提交的时候通知它们：所读到的数据现在已经发生了变化。</p><p><strong>可串行化快照隔离的性能</strong><br>一个考虑的点是跟踪事务读写的粒度，细的话那么开销可能很大，粗的话可能会扩大事务的范围。</p><p>与<strong>两阶段加锁</strong>相比，SSI最大的有点就是事务不需要等待其他事务的锁。读写不会互相影响，这样使查询的延迟更稳定、可预测。特别是在执行只读查询不需要任何的锁，对读密集的负载更有吸引力。</p><p>和<strong>串行执行</strong>相比，SSI突破了单个CPU的限制。事务即使在多个分区上读写数据也能保证串行化隔离。</p><p><strong>事务中止比例</strong>显著影响SSI的性能表现，如果一个运行时间很长的事务，读写了大量数据，那么产生冲突的可能性就很大，所以SSI要求事务尽可能简短。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一个苛刻的数据存储环境中，可能会出现很多出错的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库软件失效；&lt;/li&gt;
&lt;li&gt;应用程序随时崩溃；&lt;/li&gt;
&lt;li&gt;应用和数据库节点通信失效、数据库之间的通信失效&lt;/li&gt;
&lt;li&gt;多个客户端同时写入，导致数据覆盖；&lt;/li&gt;
&lt;li&gt;客户端可能读到无意义的、部分更新的数据；&lt;/li&gt;
&lt;li&gt;客户端之前由于边界条件竞争引入的各种奇怪问题。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="分布式" scheme="https://qinggniq.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="DDIA" scheme="https://qinggniq.com/tags/DDIA/"/>
    
  </entry>
  
  <entry>
    <title>19-10月结</title>
    <link href="https://qinggniq.com/2019/11/02/19-10%E6%9C%88%E7%BB%93/"/>
    <id>https://qinggniq.com/2019/11/02/19-10月结/</id>
    <published>2019-11-02T07:03:02.000Z</published>
    <updated>2019-11-30T06:44:53.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习"><a class="markdownIt-Anchor" href="#学习"></a> <strong>学习</strong></h2><ul><li>上半月完成了uCore操作系统的实验课程，以及相应的实验报告；</li><li>下半月完成了MIT6.824的前两个lab；</li><li>《重构》前两章；</li><li>八个题目的TestCaseGenerator；</li><li>20+LeetCode题目；</li><li>Makefile的基础写法；</li><li>DDIA的两个章节，数据复制和数据分区，以及相应笔记；</li><li>阅读了Raft、GFS、Spinnaker、FT-VitrualMachine论文；</li></ul><a id="more"></a><h2 id="生活"><a class="markdownIt-Anchor" href="#生活"></a> <strong>生活</strong></h2><ul><li>过了科二；</li><li>这个月不再带手机回寝室；</li><li>渐渐的将注意力从知乎、微博、公众号中收回；</li><li>尝试吃饭时点之前没吃过的菜；</li><li>尝试买之前没喝过的饮料；</li><li>开始和实验室学长玩飞盘；</li></ul><h2 id="11月目标"><a class="markdownIt-Anchor" href="#11月目标"></a> <strong>11月目标</strong></h2><p><strong>学习</strong></p><ul><li>完成MIT6.824的lab；</li><li>完成MIT6.824里面提到论文的总结；</li><li>系统设计题目；</li><li>DDIA三章的读书笔记；</li><li>在CMU数据库课程和写分布式选一个做；</li></ul><p><strong>生活</strong></p><ul><li>注意自己的情绪；</li><li>看《社会心理学》；</li><li>坚持冥想，收回注意力；</li><li>可能学习李沐阳看《红楼梦》；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;学习&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#学习&quot;&gt;&lt;/a&gt; &lt;strong&gt;学习&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;上半月完成了uCore操作系统的实验课程，以及相应的实验报告；&lt;/li&gt;
&lt;li&gt;下半月完成了MIT6.824的前两个lab；&lt;/li&gt;
&lt;li&gt;《重构》前两章；&lt;/li&gt;
&lt;li&gt;八个题目的TestCaseGenerator；&lt;/li&gt;
&lt;li&gt;20+LeetCode题目；&lt;/li&gt;
&lt;li&gt;Makefile的基础写法；&lt;/li&gt;
&lt;li&gt;DDIA的两个章节，数据复制和数据分区，以及相应笔记；&lt;/li&gt;
&lt;li&gt;阅读了Raft、GFS、Spinnaker、FT-VitrualMachine论文；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="life" scheme="https://qinggniq.com/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>DDIA读书笔记——第六章 数据分区</title>
    <link href="https://qinggniq.com/2019/10/30/DDIA%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA/"/>
    <id>https://qinggniq.com/2019/10/30/DDIA读书笔记——第六章-数据分区/</id>
    <published>2019-10-30T10:17:05.000Z</published>
    <updated>2019-11-30T06:44:53.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>数据复制基本只能解决容错备份问题，然而对于海量数据集或非常高的查询压力，复制技术不能解决问题，我们还需要将数据分区。</p><blockquote><p>分区通常是这样定义的，即一条数据（或者每条记录，每行或每个文档）只属于某个特定分区。</p></blockquote><p>数据分区将文档的不同部分放到不同的机器上，这样请求负载也可以分配到更多的处理器上，在单个分区进行查询时，每个节点对自己的分区可以进行独立的查询操作，所以添加更多的节点可以提高吞吐量。</p><a id="more"></a><h2 id="数据分区和数据复制"><a class="markdownIt-Anchor" href="#数据分区和数据复制"></a> 数据分区和数据复制</h2><p>它们俩比较独立，一般数据分区伴随着数据复制来提高系统容错性（参考Google File System及其工程实现HDFS）。所以一个节点可以存多个分区，一个分区可能被多个节点存储。</p><h2 id="键-值数据的分区"><a class="markdownIt-Anchor" href="#键-值数据的分区"></a> <strong>键-值数据的分区</strong></h2><p>分区的目的是<strong>将数据和查询负载尽量均匀分布在所有节点上</strong>，尽量均匀的意思是不要产生热点的情况，所以最简单的方法是<strong>随机分配</strong>，缺点是没有记录和节点间的对应关系，不得不并行查询所有节点。</p><h3 id="基于关键字区间分区"><a class="markdownIt-Anchor" href="#基于关键字区间分区"></a> <strong>基于关键字区间分区</strong></h3><p>为每个分区分配一段连续的关键字或者关键字区间范围，类似于新华字典，A字母开头的单词一个分区，B字母开头的另一个分区。</p><p>优点：</p><ul><li>可以在分区内根据关键字排序，然后区间查询十分方便</li></ul><p>缺点：</p><ul><li>某些访问模式可能会造成热点，比如测量数据如果以时间为关键字，那么今天的数据就成了热点。</li></ul><p>解决方法是用其他的内容作为关键字比如传感器名字，然后再用时间戳在分区内部排序，这样查询今天的测量数据的时候就可以在各个分区查询今天的数据了。</p><p>HBase，RethinkDB，2.4之前版本的MonogoDB。</p><h3 id="基于关键字哈希值分区"><a class="markdownIt-Anchor" href="#基于关键字哈希值分区"></a> <strong>基于关键字哈希值分区</strong></h3><p>为了避免数据倾斜与热点问题，可以使用基于关键字哈希函数的方式来分区。</p><p>找到一个合适的哈希函数，为每个分区设置一个哈希范围，关键字根据哈希值分配到不同的分区中。虽然均匀效果很好，但是失去了良好的区间查询的能力。（一致性哈希可以解决节点失效导致的数据倾斜的问题）</p><p>Cassandra使用在两个分区策略中采取了折中。它可以讲表声明为由多个列组成的复合主键。复合主键只有 第一部分用于哈希分区，其他列可以用来对Cassandra的SSTable中的数据排序。类似于传感器的例子。</p><h3 id="数据倾斜与热点"><a class="markdownIt-Anchor" href="#数据倾斜与热点"></a> <strong>数据倾斜与热点</strong></h3><p>但是无论是基于关键字区间分区还是基于哈希函数的分区，还是解决不了一些热点的情况，比如一个微博名人发布一些热点事件就可能引发一场访问风暴，出现大量关于此关键字的写操作。哈希解决不了任何问题。</p><p>一个简单的解决方法是在关键字的开头或结尾加一个随机数，但是这样以后的每个读操作都得涉及到多个节点的读取合并操作，所以这种方法只适合用在热点的关键词上。需要开发者自己来权衡设计。</p><h2 id="分区和二级索引"><a class="markdownIt-Anchor" href="#分区和二级索引"></a> <strong>分区和二级索引</strong></h2><p>关系型数据库中二级索引是标配，文档数据库也比较普遍，但是由于它的复杂性，大部分键-值数据库不支持二级索引。二级索引带来的问题是<strong>它们不能规整地映射到分区中</strong>。</p><h3 id="基于文档分区的二级索引"><a class="markdownIt-Anchor" href="#基于文档分区的二级索引"></a> <strong>基于文档分区的二级索引</strong></h3><p><img src="https://raw.githubusercontent.com/qinggniq/Note/master/GO/MIT6.824/imags/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%A1%A3%E5%88%86%E5%8C%BA%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95.png" alt="基于文档分区的二级索引"><br>当一个新的数据加入的时候，数据库会将数据加入到对应的文档ID列表。</p><p>写入、更新、删除的时候只需要处理包含目标文档ID的那个分区，因此文档分区索引也叫作本地索引。<br>但是查询的时候比如查询红色的汽车则需要查询所有的分区，然后合并结果。</p><p>MonogoDB、Riak、Cassandra、Elasticsearch、SolrCloud、VoltDB都支持基于文档的二级索引，</p><h3 id="基于词条的二级索引分区"><a class="markdownIt-Anchor" href="#基于词条的二级索引分区"></a> <strong>基于词条的二级索引分区</strong></h3><p>对所有的数据构建索引，而不是每个分区各个维护，而且全局索引不能维护在一个节点上面，否则破坏了分区平衡的目标。<img src="https://raw.githubusercontent.com/qinggniq/Note/master/GO/MIT6.824/imags/%E5%9F%BA%E4%BA%8E%E8%AF%8D%E6%9D%A1%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E5%88%86%E5%8C%BA.png" alt="基于词条的二级索引分区"></p><p>索引的划分策略可以通过之前提到的基于关键词区间和基于哈希的方法，它们的优缺点也和之前提到的一致。</p><p>基于词条的方法查询比较方便，直接根据二级索引关键词向索引所在的节点查询数据所在的分区。但是写入操作十分复杂，一条记录的写入可能涉及到多个二级索引，那么需要全部更新，而且那些二级索引一般不在一个节点上，会引起写放大。所以一般异步更新。</p><h2 id="分区再平衡"><a class="markdownIt-Anchor" href="#分区再平衡"></a> <strong>分区再平衡</strong></h2><p>由于节点的数量和数据不会保持恒定，比如一个节点上的数据越来越多，之前设计的划分策略不能达到平衡的目标了，需要再平衡。</p><ul><li>查询压力增加，需要更多CPU。</li><li>数据规模增加，需要更多磁盘和内存。</li><li>节点故障，需要其他机器接管失效节点。</li></ul><p>这些变化都要求数据和请求可以从一个节点转移到另一个节点，这个过程被称为<strong>再平衡</strong>，平衡要基本满足以下的性质：</p><ul><li>平衡后，负载、数据存储、读写请求应该在集群内更均匀的分布；</li><li>不能中断服务；</li><li>避免不必要的负载迁移，以加快再平衡，并尽量减少网络和磁盘IO的影响。</li></ul><h3 id="动态再平衡的策略"><a class="markdownIt-Anchor" href="#动态再平衡的策略"></a> <strong>动态再平衡的策略</strong></h3><p><strong>为什么不取模</strong></p><p>取模的话如果节点数量发生了变化，发生的数据迁移过大 。</p><p><strong>固定数量的分区</strong></p><p>**先创建远超实际数量的分区，然后给每个节点分配多个分区。**这样再平衡的时候选中的分区会发生迁移，但是不会改变分区和关键字的关系，只需要改变节点和分区的关系，可以逐步完成数据迁移（类似于渐进式rehash），这样旧的分区依然可以接受请求。</p><p>选择合适的分区数量是个难题，太大的话每次再平衡和数据迁移量代价就很大；如果过小，就会产生太多开销。（？？？什么开销）</p><p><strong>动态分区</strong></p><p>对于采用关键字区间分区的数据库，如果边界设置有问题，就可能会出现数据挤在一个分区里面的情况，然而设置固定边界、固定数量的分区十分不便，手动重新配置又十分繁琐。</p><p>HBase、RethinkDB使用的动态创建分区，当<strong>分区的数据操作一个可配置的阈值，就拆分为两个分区，每个一半，相反如果缩小到一定值，那么就和其他的分区合并</strong>（有点类似于物理内存管理和B树）。这样比较方便。</p><p>但是对于一个开始为空的数据库，不知道怎么设定边界，所以会从一个分区开始，在分裂之前的所有读写请求都由一个节点处理，其他的处于空闲状态。HBase和MonogoDB允许在一个空数据库上设置一些空的初始分区。</p><p><strong>按节点比例分区</strong></p><p>使分区数和集群节点成正比关系，每个节点具有固定数量的分区。所以分区的大小和数据量的大小成正比，而节点数目增加的时候需要分区大小就会变小。当新节点加入的时候随机选择固定数量的现有分区进行分裂，然后拿走这些分区的一般数据。随机选择分区边界的前提要求采用基于哈希分区，这种方法最符合一致性哈希。</p><h3 id="自动还是手动再平衡操作"><a class="markdownIt-Anchor" href="#自动还是手动再平衡操作"></a> 自动还是手动再平衡操作</h3><p>没啥可说</p><h2 id="请求路由"><a class="markdownIt-Anchor" href="#请求路由"></a> <strong>请求路由</strong></h2><p>知道数据分区到多个节点了，如何知道请求归属于哪个节点，如果发生了分区再平衡，那么它们的关系还会发生变化。</p><p>这是一类典型的<strong>服务发现</strong>的问题，服务发现不仅仅局限于数据库，任何通过网络访问的系统都有这样的需求，特别是当服务目标支持高可用的时候。有以下几种不同的策略：</p><ol><li>客户端发送请求到任意节点，然后节点自己转发到相应节点；</li><li>所有的客户端发送到一个路由，然后路由决定转发给哪个间节点；</li><li>客户端感知分区和节点的关系，然后直接发送请求到相应的节点。</li></ol><p><img src="https://raw.githubusercontent.com/qinggniq/Note/master/GO/MIT6.824/imags/%E8%AF%B7%E6%B1%82%E8%B7%AF%E7%94%B1%E6%96%B9%E5%BC%8F.png" alt="请求路由方式"></p><p>Zookeeper有解决的方法，每个节点向Zookeeper注册自己，参与者可以订阅这些位置关系，然后分区变化后，Zookeepr会主动通知到路由层。</p><p>Cassandra和Riak使用gossip协议来同步集群状态变化。虽然这样增加了复杂度，但是避免了对于Zookeeper的外部依赖。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#背景&quot;&gt;&lt;/a&gt; 背景&lt;/h2&gt;
&lt;p&gt;数据复制基本只能解决容错备份问题，然而对于海量数据集或非常高的查询压力，复制技术不能解决问题，我们还需要将数据分区。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分区通常是这样定义的，即一条数据（或者每条记录，每行或每个文档）只属于某个特定分区。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;数据分区将文档的不同部分放到不同的机器上，这样请求负载也可以分配到更多的处理器上，在单个分区进行查询时，每个节点对自己的分区可以进行独立的查询操作，所以添加更多的节点可以提高吞吐量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="分布式" scheme="https://qinggniq.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="DDIA" scheme="https://qinggniq.com/tags/DDIA/"/>
    
  </entry>
  
  <entry>
    <title>DDIA读书笔记——第五章 数据复制</title>
    <link href="https://qinggniq.com/2019/10/25/DDIA%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/"/>
    <id>https://qinggniq.com/2019/10/25/DDIA读书笔记——第五章-数据复制/</id>
    <published>2019-10-25T12:41:58.000Z</published>
    <updated>2019-11-30T06:44:53.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p><strong>多台机器上数据存储的挑战</strong></p><ul><li>扩展性：读写数量负载过大，超出当前机器的上限，需要水平扩展</li><li>容错和高可用：单台机器出现故障，系统可以继续工作</li><li>延迟考虑：CDN，选择附近的节点提供服务</li></ul><a id="more"></a><p><strong>垂直扩展的局限性</strong></p><ul><li>共享<strong>内存</strong>式的垂直扩展：价格和性能不是正比关系</li><li>共享<strong>磁盘</strong>式的垂直扩展：由于资源竞争和锁开销导致实际上不太行</li></ul><p><strong>无共享结构（水平扩展）</strong></p><ul><li>以<strong>网络</strong>进行通信：性价比高，容错，延迟低。复杂性</li></ul><p><strong>复制和分区</strong></p><ul><li><em>复制</em>：在多个节点保存相同数据的副本，提供冗余。提供容错和系统性能。</li><li><em>分区</em>：将大数据分成小的存在不同的节点上。</li></ul><h2 id="0x05-数据复制"><a class="markdownIt-Anchor" href="#0x05-数据复制"></a> 0x05 数据复制</h2><p><strong>数据复制的目的</strong></p><ul><li>物理位置更接近用户，以降低延迟</li><li>容错性</li><li>提高吞吐量</li></ul><p><strong>三种复制数据变化的方法</strong></p><ul><li>主从复制</li><li>多主节点复制</li><li>无主节点复制</li></ul><h3 id="主节点和从节点主从复制"><a class="markdownIt-Anchor" href="#主节点和从节点主从复制"></a> 主节点和从节点（主从复制）</h3><p><strong>复制原理</strong></p><ol><li>指定一个副本为主节点。客户端把写请求发给主节点，主节点先把新数据存到本地。</li><li>其他副本为从节点。主节点写完自己的后将数据更改作为<strong>复制日志</strong>或<strong>更改流</strong>发送给所有从节点。从节点收到后应用到本地并<strong>严格和主节点写入顺序一致</strong>。</li><li>从节点只读，主节点可读可写。</li></ol><h3 id="同步复制和异步复制"><a class="markdownIt-Anchor" href="#同步复制和异步复制"></a> 同步复制和异步复制</h3><ul><li><strong>同步</strong>：等到从节点复制成功再向客户端返回。</li><li><strong>异步</strong>：不等从节点的回应直接返回。</li></ul><p>一般开启同步只是说一个从节点是同步，其他的都应该是异步，一旦那个同步的节点失效了，可以将一个异步的节点提示为同步节点。</p><h3 id="配置新的从节点"><a class="markdownIt-Anchor" href="#配置新的从节点"></a> 配置新的从节点</h3><p>需要添加新的从节点时，如何保证主节点和从节点数据一致？</p><ol><li>在某个时间点产生一致性快照</li><li>拷贝快照到新的从节点</li><li>从节点请求快照之后的数据更改日志。PostGRESQL叫&quot;log sequence number&quot;，MySQL叫&quot;binlog coordinates&quot;</li><li>获得日志后开始执行日志上的数据更改，也叫<strong>追赶</strong></li></ol><h3 id="处理节点失效"><a class="markdownIt-Anchor" href="#处理节点失效"></a> 处理节点失效</h3><p><strong>从节点失效：追赶式恢复</strong><br>从节点失效后就失效了，恢复直接按照<strong>配置新的从节点</strong>那样恢复就好了。</p><p><strong>主节点失效：节点切换</strong><br>步骤：</p><ol><li><em>确认主节点失效</em>：心跳，超时。</li><li><em>选举新的主节点</em>：一致性共识算法它lei了，目标就是找到和失效主节点数据相差最小的从节点，把它变成主节点。</li><li><em>重新配置系统使得新主节点生效</em>：旧主节点再次上线得保证它降级为从节点。</li></ol><p>这里面又有很多问题：</p><ul><li>原主节点上没有复制的数据如果保留的话那么可能会导致写冲突</li><li>如果丢弃数据并且还和其他依赖数据库的内容协作，那么就十分危险</li><li>脑裂</li><li>超时时间设置导致的问题</li></ul><h3 id="复制日志的实现"><a class="markdownIt-Anchor" href="#复制日志的实现"></a> 复制日志的实现</h3><p>主要有四种：</p><ul><li>复制写操作命令</li><li>WAL，复制磁盘的变化记录（看看WAL的细节）</li><li>关系型数据库中复制表中行的变化</li><li>基于触发器的复制</li></ul><p><strong>复制写操作</strong></p><p>就是把<code>update, insert, delete</code>的语句发送给其他节点。</p><p>问题在于有些写操作不适合复制：</p><ul><li>调用非确定性函数的语句，比如<code>Now()</code>。</li><li>使用了自增列，必须得保证所有的节点按照完全相同的顺序执行，否则就会产生不一致结果</li><li>有副作用的语句，触发器、存储过程、用户定义函数</li></ul><p><strong>基于预写日志（WAL）传输</strong></p><p>记录磁盘块哪些字节发生变化，这个和存储引擎紧密耦合，升级的话得停止服务。</p><p><strong>基于行的逻辑日志复制</strong></p><p>记录行的变化，这样逻辑日志和存储引擎解耦，所以比较容易保持向后兼容。</p><p><strong>基于触发器的复制</strong></p><p>只复制想复制的数据，但是开销比较大。</p><h3 id="复制滞后的问题"><a class="markdownIt-Anchor" href="#复制滞后的问题"></a> 复制滞后的问题</h3><p>复制很慢，客户端从从节点可能看到过期的信息。</p><p><strong>最终一致性定义</strong></p><blockquote><p>这种不一致只是暂时状态，如果停止写数据库，经过一段时间后，从节点最终会赶上主节点并与主节点保持一致。这种效应也叫作最终一致性。</p></blockquote><h4 id="读自己的写"><a class="markdownIt-Anchor" href="#读自己的写"></a> 读自己的写</h4><p>由于<strong>复制滞后</strong>的问题可能导致一个用户在主节点提交了自己的修改操作而在从节点读不到自己的写，那么用户会很生气。</p><p>解决方法：</p><ul><li>如果客户访问可能会被修改的内容，那么从主节点读取；否则从从节点读取。比如用户只会修改自己主页上的东西。</li><li>大部分的内容用户都可以修改的话就不行了，那么可以根据更新时间，比如1分钟内的读就从主节点读，否则从从节点读。</li><li>记住数据副本最近更新的时间戳，如果从节点的不够新，就交给其他从节点处理。</li><li>如果在多数据中心就得把请求路由到主节点所在的数据中心。</li></ul><p>还有一些其他问题，比如跨设备共享。</p><h4 id="单调读"><a class="markdownIt-Anchor" href="#单调读"></a> 单调读</h4><p>如果用户读两次，结果之前看到的数据没有了，那么就不是单调读，可能是两次读的请求的不是一个从节点。解决方法可以根据用户IDhash路由一下。</p><h4 id="前缀一致读"><a class="markdownIt-Anchor" href="#前缀一致读"></a> 前缀一致读</h4><p>两次的写由于网络原因导致实际的写入顺序不一致，比如B是A的回答，结果回答先写入，问题后写入，这样就会导致因果倒置。这种情况在<strong>分区</strong>数据库中出现，因为只是复制的话，那么一致性保证它们的写入顺序是和主节点是一个顺序的。</p><h3 id="复制滞后的解决方案"><a class="markdownIt-Anchor" href="#复制滞后的解决方案"></a> 复制滞后的解决方案</h3><p>取决于你的业务要求，比如<strong>写后读</strong>提供了比<strong>最终一致性</strong>更强的一致性要求，但是必然会带来性能的损失和结构的复杂化，那么是否选择取决于你的业务。</p><h3 id="多主节点复制"><a class="markdownIt-Anchor" href="#多主节点复制"></a> 多主节点复制</h3><p>由于单主节点复制架构下所有的写操作都是通过的主节点，如果主节点失效，那么会影响所有的写入操作，多主节点可以解决这个问题。</p><h4 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h4><p>普通的一个数据中心不适合多主复制，因为引入的复杂度大于它所带来的好处了。一下几个场景比较合适。</p><p><strong>多数据中心</strong></p><p>一个数据中心相当于一个局域网的集群，那么多数据中心相当于在多个局域网里面分别配置一套主从复制结构，然后每个数据中心的主节点接受写请求，然后异步复制到其他数据中心的主节点。相比于普通的主从复制</p><ul><li><em>性能</em>：普通的主从复制会导致写请求发向里的比较远的主节点，而多主节点能充分利用地理位置的优势，用户体验更好。</li><li><em>容忍数据中心失效</em>：主从复制主节点失效必须迁移到另一个从节点，而多主节点可以使每个数据中心独立运行。</li><li><em>容忍网络问题</em>：由于广域网不如局域网稳定，所以普通主从复制由于是同步复制，所以更加依赖于数据中心，而多主节点因为是异步复制，所以网络中断不会影响写入成功。</li></ul><p>但是多个数据中心可能会产生写一份数据的问题，必须处理写冲突。</p><p><strong>离线客户端操作</strong></p><p>有些应用允许用户离线做的更改在上线的时候立刻同步到服务器和其他设备，所以每个设备相当于一个主节点，所有设备之间使用异步复制的方式同步这个多主节点的副本。但是网络连接十分不可靠。</p><p><strong>协同编辑</strong></p><p>需要处理写冲突。</p><h4 id="处理写冲突"><a class="markdownIt-Anchor" href="#处理写冲突"></a> 处理写冲突</h4><p>两个不同客户在不同的数据中心往一个记录写了不同的数据，由于不同数据中心是异步复制，所以在开始是不会察觉出来的。然而在写的时候不同的顺序会导致不同的结果。<br><strong>避免冲突</strong><br>设置对于特定写请求只通过一个主节点就可以避免。有时候主节点失效了需要重新路由。</p><p><strong>收敛于一致性状态</strong><br>解决方式</p><ul><li>给每个写入分配一个唯一的ID，挑最高的胜出，如果基于时间戳，那么容易造成数据丢失。</li><li>为每个副本分配一个唯一的ID，制定规则，也容易造成数据丢失。</li><li>以某种方式将这些值合并，比如B、C存为“B/C”</li><li>预定格式保存冲突信息，依靠应用层逻辑解决。</li></ul><p><strong>自定义冲突逻辑</strong><br>让用户编写代码解决冲突</p><ul><li><em>在写入的时候执行</em>：只要数据库检测到写入冲突，那么就调用用户写的冲突处理脚本。</li><li><em>在读取的时候执行</em>：在写入的时候把所有的数据保留，下次读取时把所有的数据版本返回给用户。应用层自己解决冲突。</li></ul><h4 id="拓扑结构"><a class="markdownIt-Anchor" href="#拓扑结构"></a> 拓扑结构</h4><p>复制自然有复制的方法，比如环状，就是从一个主节点到另一个主节点到最后一个主节点一直复制；比如星形，就是从一个主节发给其他所有主节点；比如全连接，从一个主节点到其他主节点，然后其他主节点再发给所有其他主节点。</p><p>环形和星形的不足就是可能会无线循环，所以需要标识符来表示是否通过，并且如果一个节点失效了，那么它们的转发可能也会失效。</p><p>但是全链接的结构可能发生日志覆盖的情况，由于网络速度不同导致的顺序不一致。</p><p>比如一个客户端X insert一个值，然后主节点在同步给其他主节点的过程中先到了B主节点，客户端Y读到了那个值，并且更新了它，发给了B主节点，B主节点又要同步这个更新操作到其他节点，而主节点C的接受顺序可能是更新操作先到而插入顺序后到。</p><p><strong>版本向量</strong>是解决这个的一个方式。</p><h3 id="无主节点复制"><a class="markdownIt-Anchor" href="#无主节点复制"></a> 无主节点复制</h3><p>无主没有主节点和从节点的区别，任何一个节点都可以处理写操作。具体的实现方式有：</p><ul><li>客户端直接发送许多写操作到所有的节点</li><li>用一个协调者来协调数据的写入，但是不负责维护写入顺序</li></ul><h4 id="节点失效时写入数据库"><a class="markdownIt-Anchor" href="#节点失效时写入数据库"></a> 节点失效时写入数据库</h4><ol><li>客户端写的时候失效</li></ol><p>客户端根本不管那些失效节点无法写入的情况。</p><ol start="2"><li>节点恢复时，客户端读</li></ol><p>此时客户端可能读到不同的值，那么客户端根据版本号来确定哪个是最新值。</p><p><strong>读修复和反熵</strong></p><blockquote><p>就是失效节点恢复后如何赶上其他节点？</p></blockquote><ul><li><em>读修复</em>：客户端读取后发现某个节点上的数据是过期的，那么把新的值写入数据库。</li><li><em>反熵</em>：后台进程找差异，不能保证以特定顺序写入，会引起明显的同步滞后。</li></ul><p><strong>读写 quorum</strong><br>写入需要w个节点确认，读入需要读r个节点，那么r + w &gt; n才能保证读出来的值至少有一个是新值。如果可用节点小于w或r那么可能会发生写入或读取错误。</p><p><strong>Quorum一致性的局限性</strong><br>大w和r能保证读取和写入的正确性，小的w和r可以获得更快的读取写入速度。然而即使是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>+</mo><mi>r</mi><mo>&gt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">w + r &gt; n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的情况下依旧可能发生返回旧值的边界条件：</p><ul><li>使用了<em>sloppy quorum</em>，写的w节点和读的r个节点可能完全不同，无法保证有重叠的节点。</li><li>如果两个写操作同时发生，无法明确先后顺序。唯一的方法就是合并写入，如果根据时间戳决定，那么由于时钟偏差的问题一些写入可能被错误的丢弃。</li><li>太多不写了</li></ul><p><strong>sloppy quorum</strong></p><ul><li>如果无法到达w或r所要求的quorum，如何明确把错误返还给客户端？</li><li>或者我们接受读请求，不过只是把它们放到一些可以访问的节点中？这些节点可能不在规定的n个节点中。</li></ul><p><em>sloppy quorum</em>对提高写可读性很有用，但是不能保证读到最新值，因为之前规定<br>的w和r不包括那些临时存储的节点。</p><p><strong>多数据中心操作</strong><br>有的模型跨数据中心，有的只能在单个数据中心设置quorum值。</p><h4 id="检测并发写"><a class="markdownIt-Anchor" href="#检测并发写"></a> 检测并发写</h4><p>写冲突在无主结构里面依然会出现，比如某个图。<br><img src="https://raw.githubusercontent.com/qinggniq/Note/master/GO/MIT6.824/imags/%E5%B9%B6%E5%8F%91%E5%86%99.png" alt="并发写入"><br>最后节点1\2\3对于X的值的结果不一致。之前写冲突有一些简单的解决方法，ID时间戳获胜、全部保留、副本ID、应用层解决。</p><p><strong>最后写入优先</strong><br>如何定义最新。由于支持并发写，那么哪个先发生就没什么意义了，所以可以对其强制排序，最后的一个获胜。牺牲了持久性，即使那些写入都对客户端报告成功，但是最终也只有一个值保留下来。</p><p><strong>happens-before关系和并发</strong><br>如何判断两个操作可不可以并发？</p><ul><li>某个操作建立在另一个操作上不能并发。</li><li>操作之间不存在因果关系可以并发。</li></ul><blockquote><p>讨论：并发的定义是啥？</p></blockquote><p>和时间无关，两个操作不需要意识到对方，那么我们可以称它们是并发操作。</p><p><strong>确定前后关系</strong><br>操作的并发处理主要靠版本号解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#背景&quot;&gt;&lt;/a&gt; 背景&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;多台机器上数据存储的挑战&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;扩展性：读写数量负载过大，超出当前机器的上限，需要水平扩展&lt;/li&gt;
&lt;li&gt;容错和高可用：单台机器出现故障，系统可以继续工作&lt;/li&gt;
&lt;li&gt;延迟考虑：CDN，选择附近的节点提供服务&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="分布式" scheme="https://qinggniq.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="DDIA" scheme="https://qinggniq.com/tags/DDIA/"/>
    
  </entry>
  
  <entry>
    <title>uCore lab8报告 文件系统设计与实现</title>
    <link href="https://qinggniq.com/2019/10/18/uCore-lab8%E6%8A%A5%E5%91%8A-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://qinggniq.com/2019/10/18/uCore-lab8报告-文件系统设计与实现/</id>
    <published>2019-10-18T11:45:15.000Z</published>
    <updated>2019-11-30T06:44:53.671Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>uCore lab7报告 同步互斥机制的设计与实现</title>
    <link href="https://qinggniq.com/2019/10/18/uCore-lab7%E6%8A%A5%E5%91%8A-%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://qinggniq.com/2019/10/18/uCore-lab7报告-同步互斥机制的设计与实现/</id>
    <published>2019-10-18T11:33:14.000Z</published>
    <updated>2019-11-30T06:44:53.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="练习0填写已有实验"><a class="markdownIt-Anchor" href="#练习0填写已有实验"></a> 练习0：填写已有实验</h2><h3 id="内容"><a class="markdownIt-Anchor" href="#内容"></a> 内容</h3><p>本实验依赖实验1/2/3/4/5/6。请把你做的实验1/2/3/4/5/6的代码填入本实验中代码中有“LAB1”/“LAB2”/“LAB3”/“LAB4”/“LAB5”/“LAB6”的注释相应部分。并确保编译通过。注意：为了能够正确执行lab7的测试应用程序，可能需对已完成的实验1/2/3/4/5/6的代码进行进一步改进。</p><a id="more"></a><h3 id="答案"><a class="markdownIt-Anchor" href="#答案"></a> 答案</h3><ul><li>注意把lab6写的<code>stride_sched.c</code>也拷过去，然后把默认的<strong>RoundRobin</strong>实现给删了；</li><li><code>trap.c</code>中将时钟中断的处理换成<code>run_timer_list()</code>；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">+    run_timer_list();</span><br><span class="line">-     sched_class_proc_tick(current);</span><br><span class="line">      <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h2 id="练习1-理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题"><a class="markdownIt-Anchor" href="#练习1-理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题"></a> 练习1: 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题</h2><h3 id="内容-2"><a class="markdownIt-Anchor" href="#内容-2"></a> 内容</h3><p>完成练习0后，建议大家比较一下（可用<code>meld</code>等文件<code>diff</code>比较软件）个人完成的lab6和练习0完成后的刚修改的lab7之间的区别，分析了解lab7采用信号量的执行过程。执行<code>make grade</code>，大部分测试用例应该通过。</p><h3 id="问答"><a class="markdownIt-Anchor" href="#问答"></a> 问答</h3><blockquote><p>请在实验报告中给出内核级信号量的设计描述，并说明其大致执行流程。</p></blockquote><ul><li>主要数据结构</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//信号量结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">wait_queue_t</span> wait_queue;</span><br><span class="line">&#125; <span class="keyword">semaphore_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> wait_head;</span><br><span class="line">&#125; <span class="keyword">wait_queue_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> wakeup_flags;</span><br><span class="line">    <span class="keyword">wait_queue_t</span> *wait_queue;</span><br><span class="line">    <span class="keyword">list_entry_t</span> wait_link;</span><br><span class="line">&#125; <span class="keyword">wait_t</span>;</span><br></pre></td></tr></table></figure><p>通过<code>wait_t</code>将等待队列与进程关联。</p><ul><li>主要执行流程<ul><li><code>down</code>判断信号量值是否大于0，大于零更新信号量之后直接返回，否则将其加入信号量的等待队列，设置当前进程状态为<strong>SLEEPING</strong>，然后重新调度，当重新执行的时候只可能是信号量可用的时候被唤醒的情况，然后出队返回。</li><li><code>up</code>判断信号量是否大于零，大于零的话说明等待队列里面没有要被唤醒的进程，否则就唤醒队头的那个进程。</li></ul></li></ul><blockquote><p>请在实验报告中给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。</p></blockquote><ul><li><code>struct semaphore</code>信号量结构</li><li><code>semaphore_init(struct semaphore* sem, size_t val)</code>初始化信号量，直接调用内核的<code>void sem_init(semaphore_t *sem, int value);</code>即可；</li><li><code>P(struct semaphore* sem)</code>尝试获取资源，调用<code>down</code>即可；</li><li><code>V(struct semaphore* sem)</code>释放资源，调用呢<code>up</code>。<br>所有的操作都得做成系统调用。</li></ul><h2 id="练习2-完成内核级条件变量和基于内核级条件变量的哲学家就餐问题"><a class="markdownIt-Anchor" href="#练习2-完成内核级条件变量和基于内核级条件变量的哲学家就餐问题"></a> 练习2: 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题</h2><h3 id="内容-3"><a class="markdownIt-Anchor" href="#内容-3"></a> 内容</h3><p>首先掌握管程机制，然后基于信号量实现完成条件变量实现，然后用管程机制实现哲学家就餐问题的解决方案（基于条件变量）。</p><h3 id="答案-2"><a class="markdownIt-Anchor" href="#答案-2"></a> 答案</h3><p>看伪代码写代码。。。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unlock one of threads waiting on the condition variable.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cond_signal</span><span class="params">(<span class="keyword">condvar_t</span> *cvp)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// LAB7 EXERCISE1: YOUR CODE</span></span><br><span class="line">  cprintf(</span><br><span class="line">      <span class="string">"cond_signal begin: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n"</span>,</span><br><span class="line">      cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   *      cond_signal(cv) &#123;</span></span><br><span class="line"><span class="comment">   *          if(cv.count&gt;0) &#123;</span></span><br><span class="line"><span class="comment">   *             mt.next_count ++;</span></span><br><span class="line"><span class="comment">   *             signal(cv.sem);</span></span><br><span class="line"><span class="comment">   *             wait(mt.next);</span></span><br><span class="line"><span class="comment">   *             mt.next_count--;</span></span><br><span class="line"><span class="comment">   *          &#125;</span></span><br><span class="line"><span class="comment">   *       &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (cvp-&gt;count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    cvp-&gt;owner-&gt;next_count++;</span><br><span class="line">    up(&amp;cvp-&gt;sem);</span><br><span class="line">    down(&amp;cvp-&gt;owner-&gt;next);</span><br><span class="line">    cvp-&gt;owner-&gt;next_count--;</span><br><span class="line">  &#125;</span><br><span class="line">  cprintf(<span class="string">"cond_signal end: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n"</span>,</span><br><span class="line">          cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cond_wait</span><span class="params">(<span class="keyword">condvar_t</span> *cvp)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// LAB7 EXERCISE1: YOUR CODE</span></span><br><span class="line">  cprintf(</span><br><span class="line">      <span class="string">"cond_wait begin:  cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n"</span>,</span><br><span class="line">      cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   *         cv.count ++;</span></span><br><span class="line"><span class="comment">   *         if(mt.next_count&gt;0)</span></span><br><span class="line"><span class="comment">   *            signal(mt.next)</span></span><br><span class="line"><span class="comment">   *         else</span></span><br><span class="line"><span class="comment">   *            signal(mt.mutex);</span></span><br><span class="line"><span class="comment">   *         wait(cv.sem);</span></span><br><span class="line"><span class="comment">   *         cv.count --;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  cvp-&gt;count++;</span><br><span class="line">  <span class="keyword">if</span> (cvp-&gt;owner-&gt;next_count)</span><br><span class="line">    up(&amp;cvp-&gt;owner-&gt;next);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    up(&amp;cvp-&gt;owner-&gt;mutex);</span><br><span class="line">  down(&amp;cvp-&gt;sem);</span><br><span class="line">  cvp-&gt;count--;</span><br><span class="line">  cprintf(<span class="string">"cond_wait end:  cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n"</span>,</span><br><span class="line">          cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;练习0填写已有实验&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#练习0填写已有实验&quot;&gt;&lt;/a&gt; 练习0：填写已有实验&lt;/h2&gt;
&lt;h3 id=&quot;内容&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#内容&quot;&gt;&lt;/a&gt; 内容&lt;/h3&gt;
&lt;p&gt;本实验依赖实验1/2/3/4/5/6。请把你做的实验1/2/3/4/5/6的代码填入本实验中代码中有“LAB1”/“LAB2”/“LAB3”/“LAB4”/“LAB5”/“LAB6”的注释相应部分。并确保编译通过。注意：为了能够正确执行lab7的测试应用程序，可能需对已完成的实验1/2/3/4/5/6的代码进行进一步改进。&lt;/p&gt;
    
    </summary>
    
    
      <category term="os" scheme="https://qinggniq.com/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>uCore lab6报告 调度框架算法设计与实现</title>
    <link href="https://qinggniq.com/2019/10/10/uCore-lab6%E6%8A%A5%E5%91%8A-%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://qinggniq.com/2019/10/10/uCore-lab6报告-调度框架算法设计与实现/</id>
    <published>2019-10-10T12:31:03.000Z</published>
    <updated>2019-11-30T06:44:53.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="练习0填写已有实验"><a class="markdownIt-Anchor" href="#练习0填写已有实验"></a> 练习0：填写已有实验</h2><p>这真的是个坑爹的练习，Lab1-5的内容并不是全部拷贝到一起就可以的，里面还有要求你更新的内容，所以就会一不小心把要更新的注释给合并没了。</p><a id="more"></a><h2 id="练习1-使用-round-robin-调度算法"><a class="markdownIt-Anchor" href="#练习1-使用-round-robin-调度算法"></a> 练习1: 使用 Round Robin 调度算法</h2><p>完成练习0后，建议大家比较一下（可用kdiff3等文件比较软件）个人完成的lab5和练习0完成后的刚修改的lab6之间的区别，分析了解lab6采用RR调度算法后的执行过程。</p><h3 id="问答"><a class="markdownIt-Anchor" href="#问答"></a> 问答</h3><blockquote><p>请理解并分析sched_class中各个函数指针的用法，并结合Round Robin 调度算法描ucore的调度执行过程</p></blockquote><p>正常几个调度点<code>trap(), do_wait(), do_yeild(), do_exit()</code>，然后<code>schedule</code>里面先入队当前的process，让这些就绪进程一起公平竞争，<code>pick_one</code>然后再出队即可。RoundRobin算法就是简单的先进先出队列，不涉及到任何排序。</p><blockquote><p>请在实验报告中简要说明如何设计实现”多级反馈队列调度算法“，给出概要设计，鼓励给出详细设计</p></blockquote><p>给process根据优先级先放到对应队列里面，设置好时间片，然后当前进程时间片用完的话出队，优先级降级，再根据优先级入队，设置时间片。选取下一个进程就是找到一个不是空的队列的队头进程运行即可。</p><h2 id="练习2-实现-stride-scheduling-调度算法"><a class="markdownIt-Anchor" href="#练习2-实现-stride-scheduling-调度算法"></a> 练习2: 实现 Stride Scheduling 调度算法</h2><h3 id="内容"><a class="markdownIt-Anchor" href="#内容"></a> 内容</h3><p>首先需要换掉RR调度器的实现，即用default_sched_stride_c覆盖default_sched.c。然后根据此文件和后续文档对Stride度器的相关描述，完成Stride调度算法的实现。</p><h3 id="答案"><a class="markdownIt-Anchor" href="#答案"></a> 答案</h3><p>Stride Scheduling算法是典型的最小堆的使用场景，所以uCore提供了一个节点结构的最小堆，然后根据<code>stride</code>的大小出队入队即可。完成这个练习首先需要确定<strong>BIG_STRIDE</strong>的值，只有<strong>max_strice - min_stride &lt;= BIG_STRIDE</strong>的时候，即使<code>stride</code>的值溢出32位无符号整形数了依然可以判断大小。其次就是简单的照注释写代码了。。。</p><h4 id="确定max_stride"><a class="markdownIt-Anchor" href="#确定max_stride"></a> 确定<strong>MAX_STRIDE</strong></h4><p>这个比较玄学，首先这个值不可能是个奇奇怪怪的值，我们可以从<strong>INT_MAX,INT_MIN, INT_MAX/2, INT_MIN/2</strong>（32位）这几个比较特殊的值中选取，由于<strong>MAX_STRIDE</strong>这个值大于零，那么看一看<strong>INT_MAX+1, INT_MAX/2+1</strong>还可不可以，emm，最后定为<strong>INT_MAX=2e31-1</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIG_STRIDE 2147483647</span></span><br></pre></td></tr></table></figure><h4 id="看注释写代码"><a class="markdownIt-Anchor" href="#看注释写代码"></a> 看注释写代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stride_init</span><span class="params">(struct run_queue *rq)</span> </span>&#123;</span><br><span class="line">  rq-&gt;lab6_run_pool = <span class="literal">NULL</span>;</span><br><span class="line">  rq-&gt;proc_num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stride_enqueue</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">  rq-&gt;lab6_run_pool = skew_heap_insert(</span><br><span class="line">      rq-&gt;lab6_run_pool, &amp;(proc-&gt;lab6_run_pool), proc_stride_comp_f);</span><br><span class="line">  <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) &#123;</span><br><span class="line">    proc-&gt;time_slice = rq-&gt;max_time_slice;</span><br><span class="line">  &#125;</span><br><span class="line">  proc-&gt;rq = rq;</span><br><span class="line">  rq-&gt;proc_num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stride_dequeue</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">  rq-&gt;lab6_run_pool = skew_heap_remove(</span><br><span class="line">      rq-&gt;lab6_run_pool, &amp;(proc-&gt;lab6_run_pool), proc_stride_comp_f);</span><br><span class="line">  rq-&gt;proc_num--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct *<span class="title">stride_pick_next</span><span class="params">(struct run_queue *rq)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (rq-&gt;lab6_run_pool == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">p</span> = <span class="title">le2proc</span>(<span class="title">rq</span>-&gt;<span class="title">lab6_run_pool</span>, <span class="title">lab6_run_pool</span>);</span></span><br><span class="line">  <span class="keyword">if</span> (p-&gt;lab6_priority == <span class="number">0</span>)</span><br><span class="line">    p-&gt;lab6_stride += BIG_STRIDE;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    p-&gt;lab6_stride += BIG_STRIDE / p-&gt;lab6_priority;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stride_proc_tick</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (proc-&gt;time_slice &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    proc-&gt;time_slice--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span>) &#123;</span><br><span class="line">    proc-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;练习0填写已有实验&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#练习0填写已有实验&quot;&gt;&lt;/a&gt; 练习0：填写已有实验&lt;/h2&gt;
&lt;p&gt;这真的是个坑爹的练习，Lab1-5的内容并不是全部拷贝到一起就可以的，里面还有要求你更新的内容，所以就会一不小心把要更新的注释给合并没了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="os" scheme="https://qinggniq.com/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>uCore lab5报告 用户进程管理</title>
    <link href="https://qinggniq.com/2019/10/10/uCore-lab5%E6%8A%A5%E5%91%8A-%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>https://qinggniq.com/2019/10/10/uCore-lab5报告-用户进程管理/</id>
    <published>2019-10-10T12:29:45.000Z</published>
    <updated>2019-11-30T06:44:53.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="练习0填写已有实验"><a class="markdownIt-Anchor" href="#练习0填写已有实验"></a> 练习0：填写已有实验</h2><p>除了将Lab1-4中练习的内容拷贝到Lab5的代码中，之前实验练习的内容还需要更新。</p><a id="more"></a><ul><li>首先是中断描述符表的初始化，实验一是全部设置为特权级0，然后<strong>T_SWITCH_TOU</strong>设置为特权级3，现在由于需要实现系统调用，所以需要把<strong>T_SYSCALL</strong>也设置为特权级3；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">idt_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">255</span>; i++) &#123;</span><br><span class="line">        SETGATE(idt[i], <span class="number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL);</span><br><span class="line">    &#125;</span><br><span class="line">    SETGATE(idt[T_SWITCH_TOU], <span class="number">1</span>, GD_KTEXT, __vectors[T_SWITCH_TOU], DPL_USER);</span><br><span class="line">+  SETGATE(idt[T_SYSCALL], <span class="number">1</span>, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);</span><br><span class="line">     lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其次是Lab4中有关<code>alloc_proc</code>中对于进程描述符的初始化，因为增加了新的属性<code>wait_state, cpro, ypro, opro</code>用来处理子进程的回收工作。</li></ul><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center">waite_state</td><td style="text-align:center">进程等待状态</td></tr><tr><td style="text-align:center">cpro</td><td style="text-align:center">进程的第一个子进程</td></tr><tr><td style="text-align:center">ypro</td><td style="text-align:center">进程的前一个兄弟</td></tr><tr><td style="text-align:center">opro</td><td style="text-align:center">进程的后一个兄弟</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct *<span class="title">alloc_proc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> = <span class="title">kmalloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">proc_struct</span>));</span></span><br><span class="line">  <span class="keyword">if</span> (proc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(proc, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct proc_struct));</span><br><span class="line">    proc-&gt;state = PROC_UNINIT;</span><br><span class="line">    proc-&gt;pid = <span class="number">0</span>;</span><br><span class="line">    proc-&gt;runs = <span class="number">0</span>;</span><br><span class="line">    proc-&gt;need_resched = <span class="number">0</span>;</span><br><span class="line">    proc-&gt;parent = current;</span><br><span class="line">    proc-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">    proc-&gt;cr3 = boot_cr3;</span><br><span class="line">    proc-&gt;flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">+  proc-&gt;wait_state = <span class="number">0</span>;</span><br><span class="line">+  proc-&gt;cptr = <span class="literal">NULL</span>;</span><br><span class="line">+  proc-&gt;yptr = <span class="literal">NULL</span>;</span><br><span class="line">+  proc-&gt;optr = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有就是<code>trap.c/trap()</code>函数里面处理时钟中断的时候需要添加<code>current-&gt;need_resched = 1;</code>，十分坑爹的是如果你用<code>make grade</code>来验证你的程序是不是正确的话，那么得把Lab1中打印100个时钟脉冲的<code>cprintf()</code>语句去掉，否则是拿不了满分的。。</p><h2 id="练习1-加载应用程序并执行需要编码"><a class="markdownIt-Anchor" href="#练习1-加载应用程序并执行需要编码"></a> 练习1: 加载应用程序并执行（需要编码）</h2><h3 id="内容"><a class="markdownIt-Anchor" href="#内容"></a> 内容</h3><p><code>do_execv</code>函数调用<code>load_icode</code>（位于<code>kern/process/proc.c</code>中）来加载并解析一个处于内存中的ELF执行文件格式的应用程序，建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好<code>proc_struct</code>结构中的成员变量<code>trapframe</code>中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的trapframe内容。</p><h3 id="答案"><a class="markdownIt-Anchor" href="#答案"></a> 答案</h3><p>答案尽在注释里。。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* LAB5:EXERCISE1 YOUR CODE</span></span><br><span class="line"><span class="comment">   * should set tf_cs,tf_ds,tf_es,tf_ss,tf_esp,tf_eip,tf_eflags</span></span><br><span class="line"><span class="comment">   * NOTICE: If we set trapframe correctly, then the user level process can</span></span><br><span class="line"><span class="comment">   * return to USER MODE from kernel. So tf_cs should be USER_CS segment (see</span></span><br><span class="line"><span class="comment">   * memlayout.h) tf_ds=tf_es=tf_ss should be USER_DS segment tf_esp should be</span></span><br><span class="line"><span class="comment">   * the top addr of user stack (USTACKTOP) tf_eip should be the entry point of</span></span><br><span class="line"><span class="comment">   * this binary program (elf-&gt;e_entry) tf_eflags should be set to enable</span></span><br><span class="line"><span class="comment">   * computer to produce Interrupt</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  tf-&gt;tf_cs = USER_CS;</span><br><span class="line">  tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;</span><br><span class="line">  tf-&gt;tf_eip = elf-&gt;e_entry;</span><br><span class="line">  tf-&gt;tf_esp = USTACKTOP;</span><br><span class="line">  tf-&gt;tf_eflags |= FL_IF;</span><br></pre></td></tr></table></figure><h3 id="问答"><a class="markdownIt-Anchor" href="#问答"></a> 问答</h3><blockquote><p>请在实验报告中描述当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的。即这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。</p></blockquote><p>设置为<strong>RUNNING</strong>后，设置<code>current</code>为该用户进程，然后调用<code>swich_to</code>函数，记得当时<code>copy_thread</code>的时候设置的<code>eip</code>为<code>forkret</code>，恢复了上下文之后<code>ret</code>会返回到<code>forkret</code>，然后<code>forkret</code>又会跳到<code>__trapret</code>，然后会将<code>proc-&gt;trap</code>里面存储的关于段寄存器的值全部存储到相应的寄存器里面，通过<code>trapframe</code>我们可以完成特权级的切换，然后就会跳到<code>tf-&gt;eip</code>那里去执行，而在<code>copy_thread</code>函数中我们知道<code>tf-&gt;eip = fn</code>，于是跳到了用户态进程执行。</p><h2 id="练习2-父进程复制自己的内存空间给子进程"><a class="markdownIt-Anchor" href="#练习2-父进程复制自己的内存空间给子进程"></a> 练习2: 父进程复制自己的内存空间给子进程</h2><h3 id="内容-2"><a class="markdownIt-Anchor" href="#内容-2"></a> 内容</h3><p>创建子进程的函数do_fork在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过copy_range函数（位于kern/mm/pmm.c中）实现的，请补充copy_range的实现，确保能够正确执行。</p><h3 id="答案-2"><a class="markdownIt-Anchor" href="#答案-2"></a> 答案</h3><p>考察函数的使用。。。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span> src_kvaddr = page2kva(page);</span><br><span class="line"><span class="keyword">uintptr_t</span> dst_kvaddr = page2kva(npage);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(dst_kvaddr, src_kvaddr, PGSIZE);</span><br><span class="line">ret = page_insert(to, npage, start, perm);</span><br><span class="line">assert(ret == <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="练习3-阅读分析源代码理解进程执行-forkexecwaitexit-的实现以及系统调用的实现"><a class="markdownIt-Anchor" href="#练习3-阅读分析源代码理解进程执行-forkexecwaitexit-的实现以及系统调用的实现"></a> 练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现</h2><h3 id="问答-2"><a class="markdownIt-Anchor" href="#问答-2"></a> 问答</h3><blockquote><p>请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的？</p></blockquote><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">影响</th></tr></thead><tbody><tr><td style="text-align:center">fork</td><td style="text-align:center">创建小新的PCB</td></tr><tr><td style="text-align:center">exec</td><td style="text-align:center">清空<code>mm</code>，<code>load_icode</code>执行新代码</td></tr><tr><td style="text-align:center">wait</td><td style="text-align:center">如果有子进程，看看有没有僵死的子进程，有的话释放资源（PCB和stack）返回状码，如果没有僵死的子进程，那么设置进程为<strong>SLEEPING</strong>状态，重新调度；没有子进程的话那么返回错误</td></tr><tr><td style="text-align:center">exit</td><td style="text-align:center">销毁<code>mm</code>，设置状态为僵死状态，如果父进程在等待的话，那么唤醒父进程，然后将改进程的子进程全部给init进程收养</td></tr></tbody></table><blockquote><p>请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）</p></blockquote><p>[RUNNING] -{do_wait}-&gt; [SLEEPING]</p><p>[SLEEPING] -{wakeup_proc}-&gt; [RUNNING]</p><p>[RUNNING] -{do_exit}-&gt; [ZOMBI]</p><p>[ZOMBI] --{be_waited}-&gt; [END]</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;练习0填写已有实验&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#练习0填写已有实验&quot;&gt;&lt;/a&gt; 练习0：填写已有实验&lt;/h2&gt;
&lt;p&gt;除了将Lab1-4中练习的内容拷贝到Lab5的代码中，之前实验练习的内容还需要更新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="os" scheme="https://qinggniq.com/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>uCore lab4报告 内核线程管理</title>
    <link href="https://qinggniq.com/2019/10/10/uCore-lab4%E6%8A%A5%E5%91%8A-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>https://qinggniq.com/2019/10/10/uCore-lab4报告-内核线程管理/</id>
    <published>2019-10-10T12:28:14.000Z</published>
    <updated>2019-11-30T06:44:53.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="练习1分配并初始化一个进程控制块需要编码"><a class="markdownIt-Anchor" href="#练习1分配并初始化一个进程控制块需要编码"></a> 练习1：分配并初始化一个进程控制块（需要编码）</h2><h3 id="内容"><a class="markdownIt-Anchor" href="#内容"></a> 内容</h3><p><code>alloc_proc</code>函数（位于<code>kern/process/proc.c</code>中）负责分配并返回一个新的<code>struct proc_struct</code>结构，用于存储新建立的内核线程的管理信息。ucore需要对这个结构进行最基本的初始化，你需要完成这个初始化过程。</p><a id="more"></a><h3 id="答案"><a class="markdownIt-Anchor" href="#答案"></a> 答案</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">enum</span> proc_state state;  <span class="comment">// Process state</span></span><br><span class="line">  <span class="keyword">int</span> pid;                <span class="comment">// Process ID</span></span><br><span class="line">  <span class="keyword">int</span> runs;               <span class="comment">// the running times of Proces</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> kstack;       <span class="comment">// Process kernel stack</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">bool</span></span><br><span class="line">  need_resched;  <span class="comment">// bool value: need to be rescheduled to release CPU?</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">parent</span>;</span>  <span class="comment">// the parent process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>        <span class="comment">// Process's memory management field</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// Switch here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span>        <span class="comment">// Trap frame for current interrupt</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> cr3;   <span class="comment">// CR3 register: the base addr of Page Directroy Table(PDT)</span></span><br><span class="line">  <span class="keyword">uint32_t</span> flags;  <span class="comment">// Process flag</span></span><br><span class="line">  <span class="keyword">char</span> name[PROC_NAME_LEN + <span class="number">1</span>];  <span class="comment">// Process name</span></span><br><span class="line">  <span class="keyword">list_entry_t</span> list_link;        <span class="comment">// Process link list</span></span><br><span class="line">  <span class="keyword">list_entry_t</span> hash_link;        <span class="comment">// Process hash list</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>就是需要你去初始化<strong>PCB</strong>里面的内容，虽然注释上是让初始化<code>struct proc_struct</code>结构里面所有的字段，但是根据<code>proc_init</code>的内容我们可以发现：</p><ul><li><code>pid</code>，<code>kstack</code>， <code>context</code>，<code>tf</code>，<code>mm</code>，<code>list_link</code>，<code>hash_link</code>在<code>do_fork()</code>时确定；</li><li><code>name</code>在<code>proc_init()</code>中确定。<br>所以只需要简单设置一下其他结构的初始值即可。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct *<span class="title">alloc_proc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> = <span class="title">kmalloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">proc_struct</span>));</span></span><br><span class="line">  <span class="keyword">if</span> (proc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// LAB4:EXERCISE1 YOUR CODE</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * below fields in proc_struct need to be initialized</span></span><br><span class="line"><span class="comment">     *       enum proc_state state;                      // Process state</span></span><br><span class="line"><span class="comment">     *       int pid;                                    // Process ID</span></span><br><span class="line"><span class="comment">     *       int runs;                                   // the running times of</span></span><br><span class="line"><span class="comment">     * Proces uintptr_t kstack;                           // Process kernel</span></span><br><span class="line"><span class="comment">     * stack volatile bool need_resched;                 // bool value: need to</span></span><br><span class="line"><span class="comment">     * be rescheduled to release CPU?</span></span><br><span class="line"><span class="comment">     * struct proc_struct *parent; // the parent</span></span><br><span class="line"><span class="comment">     * process struct mm_struct *mm;                       // Process's memory</span></span><br><span class="line"><span class="comment">     * management field struct context context;                     // Switch</span></span><br><span class="line"><span class="comment">     * here to run process struct trapframe *tf;                       // Trap</span></span><br><span class="line"><span class="comment">     * frame for current interrupt uintptr_t cr3; // CR3 register: the base addr</span></span><br><span class="line"><span class="comment">     * of Page Directroy Table(PDT) uint32_t flags; // Process flag char</span></span><br><span class="line"><span class="comment">     * name[PROC_NAME_LEN + 1];               // Process name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">memset</span>(proc, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct proc_struct));</span><br><span class="line">    proc-&gt;state = PROC_UNINIT;</span><br><span class="line">    proc-&gt;pid = <span class="number">-1</span>;</span><br><span class="line">    proc-&gt;runs = <span class="number">0</span>;</span><br><span class="line">    proc-&gt;need_resched = <span class="number">0</span>;</span><br><span class="line">    proc-&gt;parent = current;</span><br><span class="line">    proc-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    proc-&gt;cr3 = boot_cr3;</span><br><span class="line">    proc-&gt;flags = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问答"><a class="markdownIt-Anchor" href="#问答"></a> 问答</h3><blockquote><p>请说明<code>proc_struct</code>中<code>struct context context</code>和<code>struct trapframe *tf</code>成员变量含义和在本实验中的作用是啥？</p></blockquote><ul><li><code>context</code>用于上下文切换，线程切换的时候<code>context</code>用来存储线程的执行状态也就是<code>eip esp ebx ecx edx esi edi ebp</code>这一堆的寄存器的值。</li><li><code>tf</code>是实验一里面的用来存储中断栈的结构，当线程执行的时候发生了中断，实验一中断发生的时候中断信息（如<strong>ERROR_CODE, EIP, CS, 一些寄存器信息</strong>）是直接保存在栈上的，但是现在是保存在<code>proc-&gt;tf</code>结构体里面。</li></ul><h2 id="练习2为新创建的内核线程分配资源需要编码"><a class="markdownIt-Anchor" href="#练习2为新创建的内核线程分配资源需要编码"></a> 练习2：为新创建的内核线程分配资源（需要编码）</h2><h3 id="内容-2"><a class="markdownIt-Anchor" href="#内容-2"></a> 内容</h3><p>创建一个内核线程需要分配和设置好很多资源。kernel_thread函数通过调用do_fork函数完成具体内核线程的创建工作</p><h3 id="答案-2"><a class="markdownIt-Anchor" href="#答案-2"></a> 答案</h3><p>照着注释和实验书上的要点写就好了，比较坑的是有关全局数据的处理需要禁止中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* do_fork -     parent process for a new child process</span></span><br><span class="line"><span class="comment"> * @clone_flags: used to guide how to clone the child process</span></span><br><span class="line"><span class="comment"> * @stack:       the parent's user stack pointer. if stack==0, It means to fork</span></span><br><span class="line"><span class="comment"> * a kernel thread.</span></span><br><span class="line"><span class="comment"> * @tf:          the trapframe info, which will be copied to child process's</span></span><br><span class="line"><span class="comment"> * proc-&gt;tf</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_fork</span><span class="params">(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = -E_NO_FREE_PROC;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS) &#123;</span><br><span class="line">    <span class="keyword">goto</span> fork_out;</span><br><span class="line">  &#125;</span><br><span class="line">  ret = -E_NO_MEM;</span><br><span class="line">  <span class="comment">// LAB4:EXERCISE2 YOUR CODE</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Some Useful MACROs, Functions and DEFINEs, you can use them in below</span></span><br><span class="line"><span class="comment">   * implementation. MACROs or Functions: alloc_proc:   create a proc struct and</span></span><br><span class="line"><span class="comment">   * init fields (lab4:exercise1) setup_kstack: alloc pages with size KSTACKPAGE</span></span><br><span class="line"><span class="comment">   * as process kernel stack copy_mm:      process "proc" duplicate OR share</span></span><br><span class="line"><span class="comment">   * process "current"'s mm according clone_flags if clone_flags &amp; CLONE_VM,</span></span><br><span class="line"><span class="comment">   * then "share" ; else "duplicate" copy_thread:  setup the trapframe on the</span></span><br><span class="line"><span class="comment">   * process's kernel stack top and setup the kernel entry point and stack of</span></span><br><span class="line"><span class="comment">   * process hash_proc:    add proc into proc hash_list get_pid:      alloc a</span></span><br><span class="line"><span class="comment">   * unique pid for process wakeup_proc:  set proc-&gt;state = PROC_RUNNABLE</span></span><br><span class="line"><span class="comment">   * VARIABLES:</span></span><br><span class="line"><span class="comment">   *   proc_list:    the process set's list</span></span><br><span class="line"><span class="comment">   *   nr_process:   the number of process set</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//    1. call alloc_proc to allocate a proc_struct</span></span><br><span class="line">  <span class="comment">//    2. call setup_kstack to allocate a kernel stack for child process</span></span><br><span class="line">  <span class="comment">//    3. call copy_mm to dup OR share mm according clone_flag</span></span><br><span class="line">  <span class="comment">//    4. call copy_thread to setup tf &amp; context in proc_struct</span></span><br><span class="line">  <span class="comment">//    5. insert proc_struct into hash_list &amp;&amp; proc_list</span></span><br><span class="line">  <span class="comment">//    6. call wakeup_proc to make the new child process RUNNABLE</span></span><br><span class="line">  <span class="comment">//    7. set ret vaule using child proc's pid</span></span><br><span class="line">  <span class="keyword">if</span> ((proc = alloc_proc()) == <span class="literal">NULL</span>) <span class="keyword">goto</span> fork_out;</span><br><span class="line">  <span class="keyword">if</span> (setup_kstack(proc) != <span class="number">0</span>) <span class="keyword">goto</span> bad_fork_cleanup_proc;</span><br><span class="line">  <span class="keyword">if</span> (copy_mm(clone_flags, proc) != <span class="number">0</span>) <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">  copy_thread(proc, <span class="built_in">stack</span>, tf);</span><br><span class="line">  cprintf(<span class="string">"up ok !\n"</span>);</span><br><span class="line">  <span class="keyword">bool</span> intr_flag;</span><br><span class="line">  local_intr_save(intr_flag);</span><br><span class="line">  &#123;</span><br><span class="line">    list_add(&amp;proc_list, &amp;proc-&gt;list_link);</span><br><span class="line">    proc-&gt;pid = get_pid();</span><br><span class="line">    hash_proc(proc);</span><br><span class="line">    nr_process++;</span><br><span class="line">  &#125;</span><br><span class="line">  local_intr_restore(intr_flag);</span><br><span class="line">  cprintf(<span class="string">"list add ok\n"</span>);</span><br><span class="line">  wakeup_proc(proc);</span><br><span class="line"></span><br><span class="line">  ret = proc-&gt;pid;</span><br><span class="line">fork_out:</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">  put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">  kfree(proc);</span><br><span class="line">  <span class="keyword">goto</span> fork_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问答-2"><a class="markdownIt-Anchor" href="#问答-2"></a> 问答</h3><blockquote><p>请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。</p></blockquote><p>可以，根据<code>if (proc-&gt;pid == last_pid)</code>这条判断语句和之后的<code>++last_pid</code>可知，一旦循环时出现<code>proc-&gt;pid == last_pid</code>的情况就会立刻自增，不会构造出重复的id。</p><h2 id="练习3阅读代码理解-proc_run-函数和它调用的函数如何完成进程切换的"><a class="markdownIt-Anchor" href="#练习3阅读代码理解-proc_run-函数和它调用的函数如何完成进程切换的"></a> 练习3：阅读代码，理解 proc_run 函数和它调用的函数如何完成进程切换的。</h2><h3 id="问答-3"><a class="markdownIt-Anchor" href="#问答-3"></a> 问答</h3><blockquote><p>在本实验的执行过程中，创建且运行了几个内核线程？</p></blockquote><p>两个，一个<code>idleproc</code>，一个<code>initproc</code>。</p><blockquote><p>语句local_intr_save(intr_flag);…local_intr_restore(intr_flag);在这里有何作用?</p></blockquote><p>禁止中断，至于为什么，中断会破坏当前的执行吗？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;练习1分配并初始化一个进程控制块需要编码&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#练习1分配并初始化一个进程控制块需要编码&quot;&gt;&lt;/a&gt; 练习1：分配并初始化一个进程控制块（需要编码）&lt;/h2&gt;
&lt;h3 id=&quot;内容&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#内容&quot;&gt;&lt;/a&gt; 内容&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;alloc_proc&lt;/code&gt;函数（位于&lt;code&gt;kern/process/proc.c&lt;/code&gt;中）负责分配并返回一个新的&lt;code&gt;struct proc_struct&lt;/code&gt;结构，用于存储新建立的内核线程的管理信息。ucore需要对这个结构进行最基本的初始化，你需要完成这个初始化过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="os" scheme="https://qinggniq.com/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>uCore lab3报告 虚拟内存管理</title>
    <link href="https://qinggniq.com/2019/10/10/uCore-lab3%E6%8A%A5%E5%91%8A-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://qinggniq.com/2019/10/10/uCore-lab3报告-虚拟内存管理/</id>
    <published>2019-10-10T12:26:56.000Z</published>
    <updated>2019-11-30T06:44:53.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>相比于<strong>Lab1</strong>、<strong>Lab2</strong>而言，<strong>Lab3</strong>确实简单许多，只是在<strong>Lab2</strong>的基础上增加了<code>mm_area, vma_area</code>数据结构和页替换机制，然而硬件方面的并不需要我们去理解，几个练习看注释也能写出来。</p><a id="more"></a><h2 id="练习0-填写已有实验"><a class="markdownIt-Anchor" href="#练习0-填写已有实验"></a> 练习0 填写已有实验</h2><h2 id="内容"><a class="markdownIt-Anchor" href="#内容"></a> 内容</h2><p>本实验依赖实验1/2。请把你做的实验1/2的代码填入本实验中代码中有“LAB1”,“LAB2”的注释相应部分。</p><h2 id="答案"><a class="markdownIt-Anchor" href="#答案"></a> 答案</h2><p><code>meld lab2/ lab3/</code>转移即可</p><h2 id="练习1-给未被映射的地址映射上物理页需要编程"><a class="markdownIt-Anchor" href="#练习1-给未被映射的地址映射上物理页需要编程"></a> 练习1 给未被映射的地址映射上物理页（需要编程）</h2><h3 id="内容-2"><a class="markdownIt-Anchor" href="#内容-2"></a> 内容</h3><p>完成do_pgfault（mm/vmm.c）函数，给未被映射的地址映射上物理页。</p><h3 id="答案-2"><a class="markdownIt-Anchor" href="#答案-2"></a> 答案</h3><p>要完成实验需要理解<code>struct Page</code>新增的两个熟悉：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">      <span class="keyword">int</span> ref;                        <span class="comment">// page frame's reference counter</span></span><br><span class="line">      <span class="keyword">uint32_t</span> flags;                 <span class="comment">// array of flags that describe the status of the page frame</span></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> property;          <span class="comment">// the num of free block, used in first fit pm manager</span></span><br><span class="line">      <span class="keyword">list_entry_t</span> page_link;         <span class="comment">// free list link</span></span><br><span class="line"> +   <span class="keyword">list_entry_t</span> pra_page_link;     <span class="comment">// used for pra (page replace algorithm)</span></span><br><span class="line"> +   <span class="keyword">uintptr_t</span> pra_vaddr;            <span class="comment">// used for pra (page replace algorithm)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>pra_page_link</code>是页替换算法用于组织物理页的链表结构，<code>pra_vaddr</code>表明这个物理页对应哪个虚拟地址。<br><strong>页异常</strong>主要由三个原因导致：</p><ol><li><strong>缺页</strong>：即虚拟地址对应的物理地址不存在。</li><li><strong>读写权限异常</strong>：如写只读页。</li><li><strong>访问权限异常</strong>：如用户访问内核区域。</li></ol><p>下面两个情况简单返回错误即可，第一个情况根据虚拟地址是否映射到物理地址分为两种情况，还没有映射到物理地址的话就分配一个<code>Page</code>然后插入即可了；已经分配了页的虚拟地址然而物理页的内容被别的虚拟地址替换下来了，说明之前有可能通过这个虚拟地址写过这个页，然后换入到了磁盘中，所以需要再分配一个物理页然后从磁盘读入之前的数据到这个物理页。要注意的是要使用<code>do_pgfault</code>这个函数，这个函数直接完成了从获得虚拟页表项，到物理页到虚拟页的映射的过程，并且还执行了FIFO算法中入队的过程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">ptep = get_pte(mm-&gt;pgdir, addr, <span class="number">1</span>);</span><br><span class="line"> <span class="keyword">if</span> (*ptep == <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="comment">//(2) if the phy addr isn't exist, then alloc a page &amp; map the phy addr with</span></span><br><span class="line">   <span class="comment">// logical addr</span></span><br><span class="line">   <span class="comment">// struct Page *page = alloc_page();</span></span><br><span class="line">   pgdir_alloc_page(mm-&gt;pgdir, addr, perm);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">/*LAB3 EXERCISE 2: YOUR CODE</span></span><br><span class="line"><span class="comment">    * Now we think this pte is a  swap entry, we should load data from disk to</span></span><br><span class="line"><span class="comment">    * a page with phy addr, and map the phy addr with logical addr, trigger</span></span><br><span class="line"><span class="comment">    * swap manager to record the access situation of this page.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *  Some Useful MACROs and DEFINEs, you can use them in below</span></span><br><span class="line"><span class="comment">    * implementation. MACROs or Functions: swap_in(mm, addr, &amp;page) : alloc a</span></span><br><span class="line"><span class="comment">    * memory page, then according to the swap entry in PTE for addr, find the</span></span><br><span class="line"><span class="comment">    * addr of disk page, read the content of disk page into this memroy page</span></span><br><span class="line"><span class="comment">    *    page_insert ： build the map of phy addr of an Page with the linear</span></span><br><span class="line"><span class="comment">    * addr la swap_map_swappable ： set the page swappable</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">if</span> (swap_init_ok) &#123;</span><br><span class="line">     struct Page *page = <span class="literal">NULL</span>;</span><br><span class="line">     <span class="comment">//(1）According to the mm AND addr, try to load the content of right disk</span></span><br><span class="line">     <span class="comment">// page</span></span><br><span class="line">     <span class="comment">//    into the memory which page managed.</span></span><br><span class="line">     swap_in(mm, addr, &amp;page);</span><br><span class="line">     <span class="comment">//(2) According to the mm, addr AND page, setup the map of phy addr &lt;---&gt;</span></span><br><span class="line">     page_insert(mm-&gt;pgdir, page, addr, perm);</span><br><span class="line">     <span class="comment">// logical addr (3) make the page swappable.</span></span><br><span class="line">     swap_map_swappable(mm, addr, page, <span class="number">0</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     cprintf(<span class="string">"no swap_init_ok but ptep is %x, failed\n"</span>, *ptep);</span><br><span class="line">     <span class="keyword">goto</span> failed;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>注意要使用<code>pgdir_alloc_page</code>这个函数，这个函数在</p><h3 id="问答"><a class="markdownIt-Anchor" href="#问答"></a> 问答</h3><blockquote><p>请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。</p></blockquote><p>可以使用页目录项（Page Directory Entry）和页表项（Page Table Entry）中的<strong>保留位</strong>来表示页替换算法所需要的信息，如时钟置换算法就需要保留位来表示该物理页是否被修改-访问。</p><blockquote><p>如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？</p></blockquote><p>所以这个问题和Lab2的问题就是换了个条件？一个是在执行过程中，一个是在中断服务例程中，那还是没有区别，把<strong>Cr2</strong>里的内容压栈，然后把当前又缺的线性地址放入<strong>Cr2</strong>中，然后压栈<strong>error_code, CS, EIP</strong>乱七八糟的。</p><h2 id="练习2补充完成基于fifo的页面替换算法需要编程"><a class="markdownIt-Anchor" href="#练习2补充完成基于fifo的页面替换算法需要编程"></a> 练习2：补充完成基于FIFO的页面替换算法（需要编程）</h2><h3 id="内容-3"><a class="markdownIt-Anchor" href="#内容-3"></a> 内容</h3><p>完成vmm.c中的do_pgfault函数，并且在实现FIFO算法的swap_fifo.c中完成map_swappable和swap_out_victim函数。</p><h3 id="答案-3"><a class="markdownIt-Anchor" href="#答案-3"></a> 答案</h3><p><code>map_swappable</code>意思是来一个页面入队，<code>swap_out_victim</code>选一个页面出队。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _fifo_map_swappable(struct mm_struct *mm, <span class="keyword">uintptr_t</span> addr,</span><br><span class="line">                               struct Page *page, <span class="keyword">int</span> swap_in) &#123;</span><br><span class="line">  <span class="keyword">list_entry_t</span> *head = (<span class="keyword">list_entry_t</span> *)mm-&gt;sm_priv;</span><br><span class="line">  <span class="keyword">list_entry_t</span> *entry = &amp;(page-&gt;pra_page_link);</span><br><span class="line"></span><br><span class="line">  assert(entry != <span class="literal">NULL</span> &amp;&amp; head != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// record the page access situlation</span></span><br><span class="line">  <span class="comment">/*LAB3 EXERCISE 2: YOUR CODE*/</span></span><br><span class="line">  <span class="comment">//(1)link the most recent arrival page at the back of the pra_list_head</span></span><br><span class="line">  <span class="comment">// qeueue.</span></span><br><span class="line">  page-&gt;pra_vaddr = addr;</span><br><span class="line">  list_add_before(head, entry);</span><br><span class="line">  cprintf(<span class="string">"called swapple\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _fifo_swap_out_victim(struct mm_struct *mm, struct Page **ptr_page,</span><br><span class="line">                                 <span class="keyword">int</span> in_tick) &#123;</span><br><span class="line">  <span class="keyword">list_entry_t</span> *head = (<span class="keyword">list_entry_t</span> *)mm-&gt;sm_priv;</span><br><span class="line">  assert(head != <span class="literal">NULL</span>);</span><br><span class="line">  assert(in_tick == <span class="number">0</span>);</span><br><span class="line">  <span class="comment">/* Select the victim */</span></span><br><span class="line">  <span class="comment">/*LAB3 EXERCISE 2: YOUR CODE*/</span></span><br><span class="line">  <span class="comment">//(1)  unlink the  earliest arrival page in front of pra_list_head qeueue</span></span><br><span class="line">  <span class="comment">//(2)  assign the value of *ptr_page to the addr of this page</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">res</span> = <span class="title">le2page</span>(<span class="title">head</span>-&gt;<span class="title">next</span>, <span class="title">pra_page_link</span>);</span></span><br><span class="line">  *ptr_page = res;</span><br><span class="line">  list_del(head-&gt;next);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有什么要点，唯一要注意的就是入队的时候把<code>page</code>结构里面的对应的虚拟地址填一下。</p><h3 id="问答-2"><a class="markdownIt-Anchor" href="#问答-2"></a> 问答</h3><blockquote><p>如果要在ucore上实现&quot;extended clock页替换算法&quot;请给你的设计方案，现有的swap_manager框架是否足以支持在ucore中实现此算法？如果是，请给你的设计方案。如果不是，请给出你的新的扩展和基此扩展的设计方案。</p></blockquote><p>支持，<strong>extend clock页替换算法</strong>需要的信息都可以通过<code>get_pte</code>获得页表项里面保留位的信息获得。</p><h2 id="challenge-1实现识别dirty-bit的-extended-clock页替换算法需要编程"><a class="markdownIt-Anchor" href="#challenge-1实现识别dirty-bit的-extended-clock页替换算法需要编程"></a> Challenge 1：实现识别dirty bit的 extended clock页替换算法（需要编程）</h2><p>原本以为在程序访问某个虚地址的时候需要我们手动设置页表项的<code>access</code>位，后来发现原来硬件自己就能设置，于是代码就好写了很多，只要替换一下<code>swap_victim</code>函数就行了，主要就是循环链表，然后检查每个对应页表项的<code>access</code>位和<code>dirty</code>位，如果同时为0那么就是返回的结果。还需要一个<code>list_entry_t *cur</code>指向当前的位置，由于标志在查找替换页时应该从哪个页面开始。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_VISITED(pte) ((pte)&amp;PTE_A)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_WRITED(pte) ((pte)&amp;PTE_D)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">swap_manager</span> <span class="title">swap_manager_fifo</span> = &#123;</span></span><br><span class="line">    .name = <span class="string">"fifo swap manager"</span>,</span><br><span class="line">    .init = &amp;_fifo_init,</span><br><span class="line">    .init_mm = &amp;_extended_clock_init_mm,</span><br><span class="line">    .tick_event = &amp;_fifo_tick_event,</span><br><span class="line">    .map_swappable = &amp;_extended_clock_map_swapple,</span><br><span class="line">    .set_unswappable = &amp;_fifo_set_unswappable,</span><br><span class="line">    .swap_out_victim = &amp;_extended_clock_swap_out_victim,</span><br><span class="line">    .check_swap = &amp;_fifo_check_swap,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list_entry_t</span> *cur;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _extended_clock_init_mm(struct mm_struct *mm) &#123;</span><br><span class="line">  list_init(&amp;pra_list_head);</span><br><span class="line">  mm-&gt;sm_priv = &amp;pra_list_head;</span><br><span class="line">  cur = &amp;pra_list_head;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _extended_clock_map_swapple(struct mm_struct *mm, <span class="keyword">uintptr_t</span> addr,</span><br><span class="line">                                       struct Page *page, <span class="keyword">int</span> swap_in) &#123;</span><br><span class="line">  <span class="keyword">list_entry_t</span> *head = (<span class="keyword">list_entry_t</span> *)mm-&gt;sm_priv;</span><br><span class="line">  <span class="keyword">list_entry_t</span> *entry = &amp;(page-&gt;pra_page_link);</span><br><span class="line"></span><br><span class="line">  assert(entry != <span class="literal">NULL</span> &amp;&amp; head != <span class="literal">NULL</span>);</span><br><span class="line">  page-&gt;pra_vaddr = addr;</span><br><span class="line">  list_add_before(head, entry);</span><br><span class="line">  <span class="comment">// only change when first in or loop to find the victim</span></span><br><span class="line">  <span class="keyword">if</span> (cur == head) &#123;</span><br><span class="line">    cur = head-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  cprintf(<span class="string">"called swapple\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _extended_clock_swap_out_victim(struct mm_struct *mm,</span><br><span class="line">                                           struct Page **ptr_page,</span><br><span class="line">                                           <span class="keyword">int</span> in_tick) &#123;</span><br><span class="line">  <span class="keyword">list_entry_t</span> *head = (<span class="keyword">list_entry_t</span> *)mm-&gt;sm_priv;</span><br><span class="line">  assert(head != <span class="literal">NULL</span>);</span><br><span class="line">  assert(in_tick == <span class="number">0</span>);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">res</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="keyword">list_entry_t</span> *le = cur;</span><br><span class="line">  assert(head != le);</span><br><span class="line">  <span class="keyword">for</span> (;; le = le-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (le == head) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> = <span class="title">le2page</span>(<span class="title">le</span>, <span class="title">pra_page_link</span>);</span></span><br><span class="line">    <span class="keyword">pte_t</span> *pted = get_pte(mm-&gt;pgdir, page-&gt;pra_vaddr, <span class="number">0</span>);</span><br><span class="line">    assert(pted != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(IS_VISITED(*pted)) &amp;&amp; !(IS_WRITED(*pted))) &#123;</span><br><span class="line">      *ptr_page = page;</span><br><span class="line">      <span class="keyword">if</span> (le-&gt;next == head) &#123;</span><br><span class="line">        cur = le-&gt;next-&gt;next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cur = le-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      list_del(le);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_WRITED(*pted)) &#123;</span><br><span class="line">      *pted &amp;= (~PTE_D);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_VISITED(*pted)) &#123;</span><br><span class="line">      *pted &amp;= (~PTE_A);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而使用全局变量而不是<code>mm_area</code>去存下一个起始页的不好的地方在于当引入用户进程后，<code>mm_area</code>结构不止一个，那么可能A进程的页指向的是B进程的页，但是uCore原本用于存储需要换出页的链表<code>pra_page_link</code>好像就是全局的，也就没所谓了。</p><h3 id="问答-3"><a class="markdownIt-Anchor" href="#问答-3"></a> 问答</h3><blockquote><ol><li>需要被换出的页的特征是什么？</li></ol></blockquote><p><strong>访问位</strong>和<strong>修改位</strong>为0的页。</p><blockquote><ol start="2"><li>在ucore中如何判断具有这样特征的页？</li></ol></blockquote><p>检查一下页表项的<strong>访问位</strong>和<strong>修改位</strong>是不是1。</p><blockquote><ol start="3"><li>何时进行换入和换出操作？</li></ol></blockquote><p>在<code>alloc_page</code>返回<strong>NULL</strong>时进行换出，在缺页并且内容在磁盘中时进行换入。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;相比于&lt;strong&gt;Lab1&lt;/strong&gt;、&lt;strong&gt;Lab2&lt;/strong&gt;而言，&lt;strong&gt;Lab3&lt;/strong&gt;确实简单许多，只是在&lt;strong&gt;Lab2&lt;/strong&gt;的基础上增加了&lt;code&gt;mm_area, vma_area&lt;/code&gt;数据结构和页替换机制，然而硬件方面的并不需要我们去理解，几个练习看注释也能写出来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="os" scheme="https://qinggniq.com/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>uCore lab2报告 物理内存管理（含challenge）</title>
    <link href="https://qinggniq.com/2019/10/10/uCore-lab2%E6%8A%A5%E5%91%8A-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E5%90%ABchallenge%EF%BC%89/"/>
    <id>https://qinggniq.com/2019/10/10/uCore-lab2报告-物理内存管理（含challenge）/</id>
    <published>2019-10-10T11:47:19.000Z</published>
    <updated>2019-11-30T06:44:53.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="练习0填写已有实验"><a class="markdownIt-Anchor" href="#练习0填写已有实验"></a> 练习0：填写已有实验</h2><h3 id="内容"><a class="markdownIt-Anchor" href="#内容"></a> 内容</h3><p>本实验依赖实验1。请把你做的实验1的代码填入本实验中代码中有“LAB1”的注释相应部分。提示：可采用diff和patch工具进行半自动的合并（merge），也可用一些图形化的比较/merge工具来手动合并，比如meld，eclipse中的diff/merge工具，understand中的diff/merge工具等。</p><a id="more"></a><h3 id="答案"><a class="markdownIt-Anchor" href="#答案"></a> 答案</h3><p><code>meld ./lab1 ./lab2</code>将<code>lab1</code>里面的做的练习的代码移到<code>lab2</code>里面去就行。</p><h2 id="练习1实现-first-fit-连续物理内存分配算法需要编程"><a class="markdownIt-Anchor" href="#练习1实现-first-fit-连续物理内存分配算法需要编程"></a> 练习1：实现 first-fit 连续物理内存分配算法（需要编程）</h2><h3 id="实验"><a class="markdownIt-Anchor" href="#实验"></a> 实验</h3><p>在实现first fit 内存分配算法的回收函数时，要考虑地址连续的空闲块之间的合并操作。提示:在建立空闲页块链表时，需要按照空闲页块起始地址来排序，形成一个有序的链表。可能会修改default_pmm.c中的default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数。请仔细查看和理解default_pmm.c中的注释。<br>请在实验报告中简要说明你的设计实现过程。</p><h3 id="答案-2"><a class="markdownIt-Anchor" href="#答案-2"></a> 答案</h3><p>做练习一的主要内容就是理解页表项<code>Page</code>的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ref;        <span class="comment">// page frame's reference counter</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags; <span class="comment">// array of flags that describe the status of the page frame</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> property;<span class="comment">// the num of free block, used in first fit pm manager</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> page_link;<span class="comment">// free list link</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><code>ref</code>代表页表的<strong>引用计数</strong>，在引入进程后每个进程都会有一个页表，所以和智能指针一样，决定是不是释放<code>Page</code>的页是需要<code>ref</code>来标识还有没有页表引用这个物理页的。</li><li><code>flags</code>这个标志主要标识两个信息，分别在第0位和第1位：<ol><li><strong>是不是保留页</strong>，就是说是不是不能用的页，比如内核代码所在的页就是<strong>保留页</strong>，不能被用。</li><li><strong>是不是连续物理块的页头</strong>，在<strong>首次适配物理分配算法</strong>中，空闲的连续块被空闲链表组织，空闲链表里面是按地址排好序的连续物理块，连续物理块是由一个或多个物理页组成的，所以队头那个就被标志为物理块第一页了。</li></ol></li><li><code>property</code>，如果当前页是页头，那么<code>property</code>代表这页所处块有多少个页。</li><li><code>page_link</code>，用于链接到空闲链表。</li></ul><h4 id="default_init"><a class="markdownIt-Anchor" href="#default_init"></a> default_init</h4><p>不用管，默认实现。</p><h4 id="default_init_memmap"><a class="markdownIt-Anchor" href="#default_init_memmap"></a> default_init_memmap</h4><p>用于初始化最初的空闲物理页。要注意的点就是给的实现是<code>list_add(&amp;free_list, &amp;(base-&gt;page_link));</code>它会把新的空闲物理块插到<code>freelist</code>的队头去，如果初始化顺序是从小到大初始化的话，那么<code>freelist</code>里面的物理块的开始地址的顺序就是从大到小了，所以改为<code>list_add_before(&amp;free_list, &amp;(base-&gt;page_link));</code>每次插到队尾即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">default_init_memmap(struct Page *base, <span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">base</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (; p != base + n; p ++) &#123;</span><br><span class="line">        assert(PageReserved(p));</span><br><span class="line">        p-&gt;flags = p-&gt;property = <span class="number">0</span>;</span><br><span class="line">        set_page_ref(p, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    SetPageProperty(base);</span><br><span class="line">    base-&gt;property = n;</span><br><span class="line"></span><br><span class="line">    nr_free += n;</span><br><span class="line">    list_add_before(&amp;free_list, &amp;(base-&gt;page_link));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="default_alloc_pages"><a class="markdownIt-Anchor" href="#default_alloc_pages"></a> default_alloc_pages</h4><p>向外提供页分配的接口，流程就是遍历<code>freelist</code>，找到第一个足够大就保存那个块的头页指针，然后看看能不能分裂，能的话就分裂成两个，前面的物理块是实际分配出去的物理块，从<code>freelist</code>里面删除，后面的设置好<code>flag</code>位，让第一个页变成队头，再插入空闲链表里面就行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *</span></span><br><span class="line"><span class="class"><span class="title">default_alloc_pages</span>(<span class="title">size_t</span> <span class="title">n</span>) &#123;</span></span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; nr_free) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = &amp;free_list;</span><br><span class="line">    <span class="keyword">while</span> ((le = list_next(le)) != &amp;free_list) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">le2page</span>(<span class="title">le</span>, <span class="title">page_link</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;property &gt;= n) &#123;</span><br><span class="line">            page = p;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (page != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (page-&gt;property &gt; n) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">page</span> + <span class="title">n</span>;</span></span><br><span class="line">            SetPageProperty(p);</span><br><span class="line">            p-&gt;property = page-&gt;property - n;</span><br><span class="line">            list_add(&amp;(page-&gt;page_link), &amp;(p-&gt;page_link));</span><br><span class="line">&#125;</span><br><span class="line">list_del(&amp;(page-&gt;page_link));</span><br><span class="line">        nr_free -= n;</span><br><span class="line">        ClearPageProperty(page);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="default_free_pages"><a class="markdownIt-Anchor" href="#default_free_pages"></a> default_free_pages</h4><p>向外提供释放物理块的接口，流程就是先把物理块里面的页的引用计数全部清零，然后再遍历<code>freelist</code>看看能不能合并，要点就是保存合并后的物理块在<code>freelist</code>里合适的插入位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">default_free_pages(struct Page *base, <span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">base</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (; p != base + n; p ++) &#123;</span><br><span class="line">        assert(!PageReserved(p) &amp;&amp; !PageProperty(p));</span><br><span class="line">        p-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        set_page_ref(p, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    base-&gt;property = n;</span><br><span class="line">    SetPageProperty(base);</span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = list_next(&amp;free_list);</span><br><span class="line"><span class="keyword">list_entry_t</span> *nxt = &amp;free_list;</span><br><span class="line">    <span class="keyword">while</span> (le != &amp;free_list) &#123;</span><br><span class="line">        p = le2page(le, page_link);</span><br><span class="line">        le = list_next(le);</span><br><span class="line">        cprintf(<span class="string">"%08p\n"</span>, p);</span><br><span class="line">        <span class="keyword">if</span> (base + base-&gt;property == p) &#123;</span><br><span class="line">            base-&gt;property += p-&gt;property;</span><br><span class="line">            p-&gt;property = <span class="number">0</span>;</span><br><span class="line">            ClearPageProperty(p);</span><br><span class="line">nxt = (p-&gt;page_link).next;</span><br><span class="line">            list_del(&amp;(p-&gt;page_link));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p + p-&gt;property == base) &#123;</span><br><span class="line">            p-&gt;property += base-&gt;property;</span><br><span class="line">            base-&gt;property = <span class="number">0</span>;</span><br><span class="line">            ClearPageProperty(base);</span><br><span class="line">            base = p;</span><br><span class="line">nxt = (p-&gt;page_link).next;</span><br><span class="line">            list_del(&amp;(p-&gt;page_link));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (base + base-&gt;property &lt; p &amp;&amp; nxt == <span class="literal">NULL</span>) &#123;</span><br><span class="line">nxt = le;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">&#125;         </span><br><span class="line">    &#125;</span><br><span class="line">    nr_free += n;</span><br><span class="line">    list_add_before(nxt, &amp;(base-&gt;page_link));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>意思是如果合并了，那么就更新插入位置为新合并的那个位置，如果没有可以合并的，那么找到第一个合适的插入位置，由于<code>freelist</code>根据首地址排好了序，就找到第一个地址大于块尾地址的就行了。</p><h2 id="练习2实现寻找虚拟地址对应的页表项需要编程"><a class="markdownIt-Anchor" href="#练习2实现寻找虚拟地址对应的页表项需要编程"></a> 练习2：实现寻找虚拟地址对应的页表项（需要编程）</h2><h3 id="实验-2"><a class="markdownIt-Anchor" href="#实验-2"></a> 实验</h3><p>请在实验报告中简要说明你的设计实现过程。</p><h3 id="答案-3"><a class="markdownIt-Anchor" href="#答案-3"></a> 答案</h3><p><code>get_pte(pde_t *pgdir, uintptr_t la, bool create)</code>函数是让我们根据<strong>页表目录起始地址</strong>和<strong>线性地址</strong>（虚拟地址）来得到此虚拟地址的<strong>页表项(page table entry)</strong>，要点就是要理解好<strong>页目录项和页表项</strong>里面的结构。<img src="https://github.com/qinggniq/Note/blob/master/OS/Boot/ELF/formate_of_page_table_entry.png" alt="page_entry"><br>可以看到，高20位是页表地址/页框地址（注意里面是物理地址），低12位是标志位。我们通过页目录的起始地址可以知道改虚拟地址的二级页表所在的页目录项，通过<code>pde_t *pdep = &amp;pgdir[PDX(la)]</code>。然后根据<strong>PTE_P</strong>标识位得知是否有对应的二级页表，如果没有，那么根据<code>create</code>标识是否需要新分配一个页来作为二级页表。新分配页表先给<code>page</code>设置一下页表引用计数，然后清理一下二级页表所在页的内容（因为后面的程序会根据页表项的<strong>PTE_P</strong>表示判断是不是有虚拟地址到物理地址的映射），最后设置一下页目录项的访问权限标识。最后根据二级页表的起始地址找到虚拟地址所在的页表项，返回即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pte_t</span> *</span><br><span class="line">get_pte(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">bool</span> create) &#123;</span><br><span class="line"><span class="keyword">pde_t</span>* pdep = &amp;pgdir[PDX(la)];</span><br><span class="line"><span class="keyword">if</span> (!(*pdep &amp; PTE_P)) &#123;</span><br><span class="line"><span class="keyword">if</span> (create) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> = <span class="title">alloc_page</span>();</span></span><br><span class="line"><span class="keyword">if</span> (page == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">set_page_ref(page, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">uintptr_t</span> pa = page2pa(page);</span><br><span class="line"><span class="built_in">memset</span>(KADDR(pa), <span class="number">0</span>, PGSIZE);</span><br><span class="line">*pdep = pa| PTE_USER;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">uintptr_t</span>* pt_va = KADDR(PDE_ADDR(*pdep));</span><br><span class="line"><span class="comment">//cprintf("here \n");</span></span><br><span class="line"><span class="keyword">pte_t</span>* ptep = &amp;pt_va[PTX(la)]; </span><br><span class="line"><span class="keyword">return</span> ptep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问答"><a class="markdownIt-Anchor" href="#问答"></a> 问答</h2><blockquote><p>请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中每个组成部分的含义以及对ucore而言的潜在用处。</p></blockquote><table><thead><tr><th>Bit Position</th><th>Contents</th><th>Use for uCore</th></tr></thead><tbody><tr><td>0§</td><td>存在位，用于表示页表项是否有效</td><td>减小实际的页表所占空间</td></tr><tr><td>1(R/W)</td><td>访问控制位，1可写，0可读</td><td>可用于写时拷贝、防止写代码段之类的指令</td></tr><tr><td>2(U/S)</td><td>权限位，0用户模式，1内核模式</td><td>限制用户访问非法区域</td></tr><tr><td>3(PWT)</td><td>缓存位，Write-through 数据总是直接写入磁盘，Write-back (or write-behind or Write caching) 数据不是直接被写入磁盘</td><td>感觉有特殊用途</td></tr><tr><td>4(PCD)</td><td>禁止页级缓冲</td><td>不知</td></tr><tr><td>5(A)</td><td>访问位</td><td>不知</td></tr><tr><td>6</td><td>无用</td><td>无用</td></tr><tr><td>7(PS)</td><td>页大小，必须为0</td><td>无用</td></tr><tr><td>8 - 11</td><td>无用</td><td>无用</td></tr><tr><td>12-31</td><td>地址</td><td>不知</td></tr></tbody></table><blockquote><p>如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？</p></blockquote><ul><li>CR0 — Contains system control flags that control operating mode and states of the processor.</li><li>CR1 — Reserved.</li><li>CR2 — Contains the page-fault linear address (the linear address that caused a page fault).</li><li>CR3 — Contains the physical address of the base of the paging-structure hierarchy and two flags (PCD and PWT). Only the most-significant bits (less the lower 12 bits) of the base address are specified; the lower 12 bits of the address are assumed to be 0. The first paging structure must thus be aligned to a page (4-KByte) boundary. The PCD and PWT flags control caching of that paging structure in the processor’s internal data caches (they do not control TLB caching of page-directory information). When using the physical address extension, the CR3 register contains the base address of the page-directory-pointer table. In IA-32e mode, the CR3 register contains the base address of the PML4 table.</li><li>CR4 — Contains a group of flags that enable several architectural extensions, and indicate operating system or executive support for specific processor capabilities.</li></ul><p>五个控制寄存器的含义，访问内存异常后，要压入当前的线性地址到<code>cr2</code>中，然后就是正常的执行中断服务例程的操作了，压入<strong>EFLAGS</strong>，压入<strong>CS</strong>，压入<strong>EIP</strong>，压入<strong>ERROR_CODE</strong>。</p><h2 id="练习3释放某虚地址所在的页并取消对应二级页表项的映射需要编程"><a class="markdownIt-Anchor" href="#练习3释放某虚地址所在的页并取消对应二级页表项的映射需要编程"></a> 练习3：释放某虚地址所在的页并取消对应二级页表项的映射（需要编程）</h2><h3 id="实验-3"><a class="markdownIt-Anchor" href="#实验-3"></a> 实验</h3><p>当释放一个包含某虚地址的物理内存页时，需要让对应此物理内存页的管理数据结构Page做相关的清除处理，使得此物理内存页成为空闲；另外还需把表示虚地址与物理地址对应关系的二级页表项清除。请仔细查看和理解page_remove_pte函数中的注释。为此，需要补全在 kern/mm/pmm.c中的page_remove_pte函数。</p><h3 id="答案-4"><a class="markdownIt-Anchor" href="#答案-4"></a> 答案</h3><p>释放比较简单，就是看看页表项是不是真的指向了一个页框，是的话取出指向的页，然后判断页表引用计数是不是为1，为1意味着就是最后一个指向该页的页表也要释放它了，然后就调用<code>pmm_manager</code>的<code>free_page</code>，free掉就行了，最后把页表项的内容清空即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">page_remove_pte(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">pte_t</span> *ptep) &#123;</span><br><span class="line"><span class="keyword">if</span> ((*ptep &amp; PTE_P)) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> = <span class="title">pte2page</span>(*<span class="title">ptep</span>);</span></span><br><span class="line"><span class="keyword">if</span> (page == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">page_ref_dec(page);</span><br><span class="line"><span class="keyword">if</span> (page-&gt;ref == <span class="number">0</span>) &#123;</span><br><span class="line">free_page(page);</span><br><span class="line">tlb_invalidate(pgdir, la);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">((<span class="keyword">pte_t</span> *)KADDR(PDE_ADDR(pgdir[PDX(la)])))[PTX(la)] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问答-2"><a class="markdownIt-Anchor" href="#问答-2"></a> 问答</h3><blockquote><p>数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？</p></blockquote><p>有对应关系，页表项或页目录项如果有<strong>PTE_P</strong>标志的话，那么其中存的物理地址左移12位就是对应的page结构。</p><blockquote><p>如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？ 鼓励通过编程来具体完成这个问题</p></blockquote><p>把那些物理地址转虚拟地址的宏用到的<strong>KERNBASE</strong>改成0，然后<code>keld.ld</code>中的加载地址改为0x0。</p><h2 id="challenge-完成buddy算法"><a class="markdownIt-Anchor" href="#challenge-完成buddy算法"></a> Challenge 完成Buddy算法</h2><p>实验知道书上提供的<a href="http://coolshell.cn/articles/10427.html" target="_blank" rel="noopener">伙伴算法的极简实现</a>中的算法十分的简洁，所以直接修改代码将其适应到uCore框架里面来即可。<br>适应到uCore框架的要点在于控制信息的存放和原实现中offset到实际的物理页的映射。</p><h3 id="控制信息"><a class="markdownIt-Anchor" href="#控制信息"></a> 控制信息</h3><p><code>struct buddy</code>用来存储可用页面数和位图。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buddy</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    <span class="keyword">size_t</span> longest[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>size</code>指需要管理的物理页面数</li><li><code>longest</code>用<strong>堆排序</strong>的结构表示当前节点能分配的最大页面数。</li></ul><p>控制信息主要有以下变量：</p><table><thead><tr><th style="text-align:center">变量名</th><th style="text-align:center">类型</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center">buddy_manager</td><td style="text-align:center">struct buddy</td><td style="text-align:center">控制结构体</td></tr><tr><td style="text-align:center">manage_size</td><td style="text-align:center">size_t</td><td style="text-align:center">控制信息占据的空间大小</td></tr><tr><td style="text-align:center">manage_page_cnt</td><td style="text-align:center">size_t</td><td style="text-align:center">buddy_manager控制信息所占的物理页面数</td></tr><tr><td style="text-align:center">manage_base</td><td style="text-align:center">Page*</td><td style="text-align:center">控制信息存储页面</td></tr><tr><td style="text-align:center">alloc_page_base</td><td style="text-align:center">Page *</td><td style="text-align:center">实际分配页面的起始页面地址</td></tr></tbody></table><h3 id="需要的宏定义"><a class="markdownIt-Anchor" href="#需要的宏定义"></a> 需要的宏定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index from 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUDDY_ROOT_SIZE (buddy_manager-&gt;longest[0])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT(idx) ((idx &lt;&lt; 1) + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT(idx) (((idx) &lt;&lt; 1) + 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PARENT(idx) (((idx) + 1) / 2 - 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_POWER_OF_2(x) (!((x) &amp; ((x) - 1)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="comment">// Bitwise operate</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UINT32_SHR_OR(a,n)      ((a)|((a)&gt;&gt;(n)))   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UINT32_MASK(a)          (UINT32_SHR_OR(UINT32_SHR_OR(UINT32_SHR_OR(UINT32_SHR_OR(UINT32_SHR_OR(a,1),2),4),8),16))    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UINT32_REMAINDER(a)     ((a)&amp;(UINT32_MASK(a)&gt;&gt;1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UINT32_ROUND_UP(a)      (UINT32_REMAINDER(a)?(((a)-UINT32_REMAINDER(a))&lt;&lt;1):(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UINT32_ROUND_DOWN(a)    (UINT32_REMAINDER(a)?((a)-UINT32_REMAINDER(a)):(a))</span></span><br></pre></td></tr></table></figure><h3 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">buddy_init(<span class="keyword">void</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">init_buddy_manager(struct Page* base, <span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    buddy_manager = page2kva(base);</span><br><span class="line">    manage_base = base;</span><br><span class="line">    <span class="comment">//buddy只能管理2的次幂的内存</span></span><br><span class="line">    buddy_manager-&gt;size = UINT32_ROUND_DOWN(n);</span><br><span class="line">    <span class="comment">//堆的结构的节点是实际物理页面数的两倍 sizeof(buddy_manager) = node_size * sizeof(size_t)</span></span><br><span class="line">    manage_size = buddy_manager-&gt;size * <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>); </span><br><span class="line">    <span class="comment">//控制信息所占的物理页面数</span></span><br><span class="line">    manage_page_cnt = (manage_size - <span class="number">1</span>) / PGSIZE + <span class="number">1</span>; </span><br><span class="line">    <span class="comment">//控制信息之后便是实际分配地址</span></span><br><span class="line">    alloc_page_base = base + manage_page_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> node_size = buddy_manager-&gt;size * <span class="number">2</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * buddy_manager-&gt;size - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (IS_POWER_OF_2(i + <span class="number">1</span>))</span><br><span class="line">            node_size &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        buddy_manager-&gt;longest[i] = node_size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">buddy_init_memmap(struct Page* base, <span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">base</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (; p != base + n; p ++) &#123;</span><br><span class="line">        assert(PageReserved(p));</span><br><span class="line">        p-&gt;flags = p-&gt;property = <span class="number">0</span>;</span><br><span class="line">        set_page_ref(p, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init_buddy_manager(base, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *</span></span><br><span class="line"><span class="class"><span class="title">buddy_alloc_pages</span>(<span class="title">size_t</span> <span class="title">n</span>) &#123;</span></span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line">    n = UINT32_ROUND_UP(n); <span class="comment">// fix it to the pow of 2</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; BUDDY_ROOT_SIZE) &#123;  <span class="comment">//no space</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> node_size;</span><br><span class="line">    <span class="keyword">size_t</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> left_longest;</span><br><span class="line">    <span class="keyword">size_t</span> right_longest;</span><br><span class="line">    <span class="comment">//一直向下查找，找到第一个刚好比所需内存大的物理块分配</span></span><br><span class="line">    <span class="keyword">for</span> (node_size = buddy_manager-&gt;size; node_size != n; node_size &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        left_longest = buddy_manager-&gt;longest[LEFT(idx)] ;</span><br><span class="line">        right_longest = buddy_manager-&gt;longest[RIGHT(idx)];</span><br><span class="line">        <span class="comment">//find the suitable node but not split the large block</span></span><br><span class="line">        <span class="keyword">if</span> (left_longest &gt;= n &amp;&amp; right_longest &gt;= n) &#123; </span><br><span class="line">            <span class="keyword">if</span> (left_longest &lt;= right_longest) &#123;</span><br><span class="line">                idx = LEFT(idx);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                idx = RIGHT(idx);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (left_longest &gt;= n) &#123;</span><br><span class="line">                idx = LEFT(idx);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                idx = RIGHT(idx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buddy_manager-&gt;longest[idx] = <span class="number">0</span>;</span><br><span class="line">    offset = (idx + <span class="number">1</span>) * node_size - buddy_manager-&gt;size; <span class="comment">//to calculate the offset of the alloc_base</span></span><br><span class="line">    <span class="comment">//更新各个节点能分配的最大物理块大小</span></span><br><span class="line">    <span class="keyword">while</span> (idx) &#123;</span><br><span class="line">        idx = PARENT(idx);</span><br><span class="line">        buddy_manager-&gt;longest[idx] = MAX(buddy_manager-&gt;longest[LEFT(idx)], buddy_manager-&gt;longest[RIGHT(idx)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> alloc_page_base + offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">buddy_free_pages(struct Page *base, <span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line">    n = UINT32_ROUND_UP(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> offset = base - alloc_page_base;</span><br><span class="line">    cprintf(<span class="string">"free %08p --- %d\n"</span>, base, offset);</span><br><span class="line">    assert(offset &lt; buddy_manager-&gt;size); <span class="comment">// ????</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span>  idx = offset + buddy_manager-&gt;size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> node_size = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//找到这个页面是由哪个节点分配出去的</span></span><br><span class="line">    <span class="keyword">for</span> (; buddy_manager-&gt;longest[idx]; idx = PARENT(idx)) &#123;</span><br><span class="line">        node_size &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> left_longest;</span><br><span class="line">    <span class="keyword">size_t</span> right_longest;</span><br><span class="line">    buddy_manager-&gt;longest[idx] = node_size;</span><br><span class="line">    <span class="comment">//由当前节点开始向上回溯，如果节点的左右孩子都是满状态的话，那么这个节点也更新为满状态，否则更新为左右孩子的最大值</span></span><br><span class="line">    <span class="keyword">while</span> (idx) &#123;</span><br><span class="line">        idx = PARENT(idx);</span><br><span class="line">        node_size &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        left_longest = buddy_manager-&gt;longest[LEFT(idx)];</span><br><span class="line">        right_longest = buddy_manager-&gt;longest[RIGHT(idx)];</span><br><span class="line">        <span class="keyword">if</span> (left_longest + right_longest == node_size) &#123;</span><br><span class="line">            cprintf(<span class="string">"free %d %d\n"</span>, idx, node_size);</span><br><span class="line">            buddy_manager-&gt;longest[idx] = node_size;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             buddy_manager-&gt;longest[idx] = MAX(left_longest, right_longest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span></span><br><span class="line">buddy_nr_free_pages(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> buddy_manager-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">macro_check(<span class="keyword">void</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bitwise operate check</span></span><br><span class="line">    assert(UINT32_SHR_OR(<span class="number">0xCC</span>, <span class="number">2</span>) == <span class="number">0xFF</span>);</span><br><span class="line">    assert(UINT32_MASK(<span class="number">0x4000</span>) == <span class="number">0x7FFF</span>);</span><br><span class="line">    assert(UINT32_REMAINDER(<span class="number">0x4321</span>) == <span class="number">0x321</span>);</span><br><span class="line">    assert(UINT32_ROUND_UP(<span class="number">0x2321</span>) == <span class="number">0x4000</span>);</span><br><span class="line">    assert(UINT32_ROUND_UP(<span class="number">0x2000</span>) == <span class="number">0x2000</span>);</span><br><span class="line">    assert(UINT32_ROUND_DOWN(<span class="number">0x4321</span>) == <span class="number">0x4000</span>);</span><br><span class="line">    assert(UINT32_ROUND_DOWN(<span class="number">0x4000</span>) == <span class="number">0x4000</span>);</span><br><span class="line"></span><br><span class="line">    assert(PARENT(<span class="number">1</span>) == <span class="number">0</span>);</span><br><span class="line">    assert(PARENT(<span class="number">2</span>) == <span class="number">0</span>);</span><br><span class="line">    assert(PARENT(<span class="number">3</span>) == <span class="number">1</span>);</span><br><span class="line">    assert(PARENT(<span class="number">4</span>) == <span class="number">1</span>);</span><br><span class="line">    assert(PARENT(<span class="number">5</span>) == <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">size_check(<span class="keyword">void</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> buddy_alloc_size = buddy_manager-&gt;size;</span><br><span class="line"></span><br><span class="line">    init_buddy_manager(manage_base, <span class="number">1024</span>);</span><br><span class="line">    assert(buddy_manager-&gt;size == <span class="number">1024</span>);</span><br><span class="line">    init_buddy_manager(manage_base, <span class="number">1026</span>);</span><br><span class="line">    assert(buddy_manager-&gt;size == <span class="number">1024</span>);</span><br><span class="line">    init_buddy_manager(manage_base, <span class="number">1028</span>);    </span><br><span class="line">    assert(buddy_manager-&gt;size == <span class="number">1024</span>);</span><br><span class="line">    init_buddy_manager(manage_base, buddy_alloc_size);   </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">alloc_check(<span class="keyword">void</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build buddy system for test</span></span><br><span class="line">    <span class="keyword">size_t</span> buddy_alloc_size = buddy_manager-&gt;size;</span><br><span class="line">    <span class="keyword">for</span> (struct Page *p = manage_base; p &lt; manage_base + <span class="number">1026</span>; p++)</span><br><span class="line">        SetPageReserved(p);</span><br><span class="line">    buddy_init();</span><br><span class="line">    buddy_init_memmap(manage_base, <span class="number">1026</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check allocation</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p0</span>, *<span class="title">p1</span>, *<span class="title">p2</span>, *<span class="title">p3</span>;</span></span><br><span class="line">    p0 = p1 = p2 = <span class="literal">NULL</span>;</span><br><span class="line">    assert((p0 = alloc_page()) != <span class="literal">NULL</span>);</span><br><span class="line">    assert((p1 = alloc_page()) != <span class="literal">NULL</span>);</span><br><span class="line">    assert((p2 = alloc_page()) != <span class="literal">NULL</span>);</span><br><span class="line">    assert((p3 = alloc_page()) != <span class="literal">NULL</span>);</span><br><span class="line">    cprintf(<span class="string">"p0 - base = %d, p1 - base = %d. p2 - base = %d, p3 - base = %d\n"</span>, \</span><br><span class="line">    p0 - alloc_page_base, p1 - alloc_page_base, p2 - alloc_page_base, p3 - alloc_page_base);</span><br><span class="line">    assert(p0 + <span class="number">1</span> == p1);</span><br><span class="line">    assert(p1 + <span class="number">1</span> == p2);</span><br><span class="line">    assert(p2 + <span class="number">1</span> == p3);</span><br><span class="line">    assert(page_ref(p0) == <span class="number">0</span> &amp;&amp; page_ref(p1) == <span class="number">0</span> &amp;&amp; page_ref(p2) == <span class="number">0</span> &amp;&amp; page_ref(p3) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    assert(page2pa(p0) &lt; npage * PGSIZE);</span><br><span class="line">    assert(page2pa(p1) &lt; npage * PGSIZE);</span><br><span class="line">    assert(page2pa(p2) &lt; npage * PGSIZE);</span><br><span class="line">    assert(page2pa(p3) &lt; npage * PGSIZE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check release</span></span><br><span class="line">    free_page(p0);</span><br><span class="line">    free_page(p1);</span><br><span class="line">    free_page(p2);</span><br><span class="line">    cprintf(<span class="string">"p3 - base = %d\n"</span>,  p3 - alloc_page_base);</span><br><span class="line">    assert((p1 = alloc_page()) != <span class="literal">NULL</span>);</span><br><span class="line">    assert((p0 = alloc_pages(<span class="number">2</span>)) != <span class="literal">NULL</span>);</span><br><span class="line">    cprintf(<span class="string">"p0 - base = %d, p1 - base = %d\n"</span>, p0 - alloc_page_base, p1 - alloc_page_base);</span><br><span class="line">    assert(p0 + <span class="number">2</span> == p1);</span><br><span class="line"></span><br><span class="line">    free_pages(p0, <span class="number">2</span>);</span><br><span class="line">    free_page(p1);</span><br><span class="line">    free_page(p3);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line">    assert((p = alloc_pages(<span class="number">4</span>)) == p0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restore buddy system</span></span><br><span class="line">    <span class="keyword">for</span> (struct Page *p = manage_base; p &lt; manage_base + buddy_alloc_size; p++)</span><br><span class="line">        SetPageReserved(p);</span><br><span class="line">    buddy_init();</span><br><span class="line">    buddy_init_memmap(manage_base, buddy_alloc_size);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line">buddy_check(<span class="keyword">void</span>) &#123;</span><br><span class="line">    macro_check();</span><br><span class="line">    size_check();</span><br><span class="line">    alloc_check();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pmm_manager</span> <span class="title">buddy_pmm_manager</span> = &#123;</span></span><br><span class="line">    .name = <span class="string">"buddy_pmm_manager"</span>,</span><br><span class="line">    .init = buddy_init,</span><br><span class="line">    .init_memmap = buddy_init_memmap,</span><br><span class="line">    .alloc_pages = buddy_alloc_pages,</span><br><span class="line">    .free_pages = buddy_free_pages,</span><br><span class="line">    .nr_free_pages = buddy_nr_free_pages,</span><br><span class="line">    .check = buddy_check,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;练习0填写已有实验&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#练习0填写已有实验&quot;&gt;&lt;/a&gt; 练习0：填写已有实验&lt;/h2&gt;
&lt;h3 id=&quot;内容&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#内容&quot;&gt;&lt;/a&gt; 内容&lt;/h3&gt;
&lt;p&gt;本实验依赖实验1。请把你做的实验1的代码填入本实验中代码中有“LAB1”的注释相应部分。提示：可采用diff和patch工具进行半自动的合并（merge），也可用一些图形化的比较/merge工具来手动合并，比如meld，eclipse中的diff/merge工具，understand中的diff/merge工具等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="os" scheme="https://qinggniq.com/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>uCore lab1报告 从机器启动到操作系统运行的过程</title>
    <link href="https://qinggniq.com/2019/10/10/uCore-lab1%E6%8A%A5%E5%91%8A/"/>
    <id>https://qinggniq.com/2019/10/10/uCore-lab1报告/</id>
    <published>2019-10-10T11:40:58.000Z</published>
    <updated>2019-11-30T06:44:53.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="练习一"><a class="markdownIt-Anchor" href="#练习一"></a> 练习一</h2><h3 id="操作系统镜像文件ucoreimg是如何一步一步生成的"><a class="markdownIt-Anchor" href="#操作系统镜像文件ucoreimg是如何一步一步生成的"></a> 操作系统镜像文件ucore.img是如何一步一步生成的？</h3><h4 id="1-构建kernel"><a class="markdownIt-Anchor" href="#1-构建kernel"></a> 1. 构建kernel</h4><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">+ cc kern/init/init.c</span><br><span class="line">gcc -Ikern/init/ -march=i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/init/init.c -o obj/kern/init/init.o</span><br><span class="line">+ cc kern/libs/stdio.c</span><br><span class="line">gcc -Ikern/libs/ -march=i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/libs/stdio.c -o obj/kern/libs/stdio.o</span><br><span class="line">+ cc kern/libs/readline.c</span><br><span class="line">gcc -Ikern/libs/ -march=i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/libs/readline.c -o obj/kern/libs/readline.o</span><br><span class="line">+ cc kern/debug/panic.c</span><br><span class="line">gcc -Ikern/debug/ -march=i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/panic.c -o obj/kern/debug/panic.o</span><br><span class="line">+ cc kern/debug/kdebug.c</span><br><span class="line">gcc -Ikern/debug/ -march=i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/kdebug.c -o obj/kern/debug/kdebug.o</span><br><span class="line">+ cc kern/debug/kmonitor.c</span><br><span class="line">gcc -Ikern/debug/ -march=i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/kmonitor.c -o obj/kern/debug/kmonitor.o</span><br><span class="line">+ cc kern/driver/clock.c</span><br><span class="line">gcc -Ikern/driver/ -march=i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/clock.c -o obj/kern/driver/clock.o</span><br><span class="line">+ cc kern/driver/console.c</span><br><span class="line">gcc -Ikern/driver/ -march=i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/console.c -o obj/kern/driver/console.o</span><br><span class="line">+ cc kern/driver/picirq.c</span><br><span class="line">gcc -Ikern/driver/ -march=i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/picirq.c -o obj/kern/driver/picirq.o</span><br><span class="line">+ cc kern/driver/intr.c</span><br><span class="line">gcc -Ikern/driver/ -march=i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/intr.c -o obj/kern/driver/intr.o</span><br><span class="line">+ cc kern/trap/trap.c</span><br><span class="line">gcc -Ikern/trap/ -march=i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/trap.c -o obj/kern/trap/trap.o</span><br><span class="line">+ cc kern/trap/vectors.S</span><br><span class="line">gcc -Ikern/trap/ -march=i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/vectors.S -o obj/kern/trap/vectors.o</span><br><span class="line">+ cc kern/trap/trapentry.S</span><br><span class="line">gcc -Ikern/trap/ -march=i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/trapentry.S -o obj/kern/trap/trapentry.o</span><br><span class="line">+ cc kern/mm/pmm.c</span><br><span class="line">gcc -Ikern/mm/ -march=i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/mm/pmm.c -o obj/kern/mm/pmm.o</span><br><span class="line">+ cc libs/string.c</span><br><span class="line">gcc -Ilibs/ -march=i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/  -c libs/string.c -o obj/libs/string.o</span><br><span class="line">+ cc libs/printfmt.c</span><br><span class="line">gcc -Ilibs/ -march=i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/  -c libs/printfmt.c -o obj/libs/printfmt.o</span><br><span class="line">+ ld bin/kernel</span><br><span class="line">ld -m    elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/stdio.o obj/kern/libs/readline.o obj/kern/debug/panic.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/picirq.o obj/kern/driver/intr.o obj/kern/trap/trap.o obj/kern/trap/vectors.o obj/kern/trap/trapentry.o obj/kern/mm/pmm.o  obj/libs/string.o obj/libs/printfmt.o</span><br></pre></td></tr></table></figure><h4 id="2-构建bootloader"><a class="markdownIt-Anchor" href="#2-构建bootloader"></a> 2. 构建bootloader</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ cc boot/bootasm.S</span><br><span class="line">gcc -Iboot/ -march=i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o</span><br><span class="line">+ cc boot/bootmain.c</span><br><span class="line">gcc -Iboot/ -march=i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootmain.c -o obj/boot/bootmain.o</span><br><span class="line">+ cc tools/sign.c</span><br><span class="line">gcc -Itools/ -g -Wall -O2 -c tools/sign.c -o obj/sign/tools/sign.o</span><br><span class="line">gcc -g -Wall -O2 obj/sign/tools/sign.o -o bin/sign</span><br><span class="line">+ ld bin/bootblock</span><br><span class="line">ld -m    elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o</span><br></pre></td></tr></table></figure><h4 id="3-制作ucore镜像"><a class="markdownIt-Anchor" href="#3-制作ucore镜像"></a> 3. 制作ucore镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">build 512 bytes boot sector: &apos;bin/bootblock&apos; success!</span><br><span class="line">dd if=/dev/zero of=bin/ucore.img count=10000</span><br><span class="line">dd if=bin/bootblock of=bin/ucore.img conv=notrunc</span><br><span class="line">dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc</span><br></pre></td></tr></table></figure><h3 id="一个被系统认为是符合规范的硬盘主引导扇区的特征是什么"><a class="markdownIt-Anchor" href="#一个被系统认为是符合规范的硬盘主引导扇区的特征是什么"></a> 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</h3><p>最后两个字节是<strong>0x55</strong>和<strong>0xAA</strong></p><h2 id="练习二"><a class="markdownIt-Anchor" href="#练习二"></a> 练习二</h2><h3 id="1-从cpu加电后执行的第一条指令开始单步跟踪bios的执行"><a class="markdownIt-Anchor" href="#1-从cpu加电后执行的第一条指令开始单步跟踪bios的执行"></a> 1. 从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/i $pc</span><br></pre></td></tr></table></figure><h3 id="2-在初始化位置0x7c00设置实地址断点测试断点正常"><a class="markdownIt-Anchor" href="#2-在初始化位置0x7c00设置实地址断点测试断点正常"></a> 2. 在初始化位置0x7c00设置实地址断点,测试断点正常。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x7c00</span><br></pre></td></tr></table></figure><h3 id="3-从0x7c00开始跟踪代码运行将单步跟踪反汇编得到的代码与bootasms和-bootblockasm进行比较"><a class="markdownIt-Anchor" href="#3-从0x7c00开始跟踪代码运行将单步跟踪反汇编得到的代码与bootasms和-bootblockasm进行比较"></a> 3. 从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较。</h3><h3 id="4-自己找一个bootloader或内核中的代码位置设置断点并进行测试"><a class="markdownIt-Anchor" href="#4-自己找一个bootloader或内核中的代码位置设置断点并进行测试"></a> 4. 自己找一个bootloader或内核中的代码位置，设置断点并进行测试。</h3><h2 id="练习三"><a class="markdownIt-Anchor" href="#练习三"></a> 练习三</h2><h3 id="bios将通过读取硬盘主引导扇区到内存并转跳到对应内存中的位置执行bootloader-请分析bootloader是如何完成从实模式进入保护模式的"><a class="markdownIt-Anchor" href="#bios将通过读取硬盘主引导扇区到内存并转跳到对应内存中的位置执行bootloader-请分析bootloader是如何完成从实模式进入保护模式的"></a> BIOS将通过读取硬盘主引导扇区到内存，并转跳到对应内存中的位置执行bootloader。请分析bootloader是如何完成从实模式进入保护模式的。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lgdt gdtdesc</span><br><span class="line">    movl %cr0, %eax</span><br><span class="line">    orl $CR0_PE_ON, %eax</span><br><span class="line">    movl %eax, %cr0</span><br><span class="line"></span><br><span class="line">      ljmp $PROT_MODE_CSEG, $protcseg</span><br></pre></td></tr></table></figure><p>通过写键盘控制器开启A20线，指定gdt表位置，将<code>%cr0</code>寄存器最后一位置1，开始保护模式。<code>ljmp $PROT_MODE_CSEG, $protcseg</code>用来改变<code>cs</code>寄存器的值，<strong>PROT_MODE_CSEG</strong>指向代码段描述符位置。</p><h2 id="练习4分析bootloader加载elf格式的os的过程-要求在报告中写出分析"><a class="markdownIt-Anchor" href="#练习4分析bootloader加载elf格式的os的过程-要求在报告中写出分析"></a> 练习4：分析bootloader加载ELF格式的OS的过程。（要求在报告中写出分析）</h2><h3 id="bootloader如何读取硬盘扇区的"><a class="markdownIt-Anchor" href="#bootloader如何读取硬盘扇区的"></a> bootloader如何读取硬盘扇区的？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">等待磁盘准备好</span><br><span class="line">发出读取扇区的命令</span><br><span class="line">等待磁盘准备好</span><br><span class="line">把磁盘扇区数据读到指定内存</span><br></pre></td></tr></table></figure><h3 id="bootloader是如何加载elf格式的os"><a class="markdownIt-Anchor" href="#bootloader是如何加载elf格式的os"></a> bootloader是如何加载ELF格式的OS？</h3><ol><li>先读kernel的ELFheader</li><li>判断是不是ELFheader</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> &#123;</span></span><br><span class="line">  uint magic;  <span class="comment">// must equal ELF_MAGIC</span></span><br><span class="line">  uchar elf[<span class="number">12</span>];</span><br><span class="line">  ushort type;</span><br><span class="line">  ushort machine;</span><br><span class="line">  uint version;</span><br><span class="line">  uint entry;  <span class="comment">// 程序入口的虚拟地址</span></span><br><span class="line">  uint phoff;  <span class="comment">// program header 表的位置偏移</span></span><br><span class="line">  uint shoff;</span><br><span class="line">  uint flags;</span><br><span class="line">  ushort ehsize;</span><br><span class="line">  ushort phentsize;</span><br><span class="line">  ushort phnum; <span class="comment">//program header表中的入口数目</span></span><br><span class="line">  ushort shentsize;</span><br><span class="line">  ushort shnum;</span><br><span class="line">  ushort shstrndx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>算出程序段偏移和大小</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> &#123;</span></span><br><span class="line">  uint type;   <span class="comment">// 段类型</span></span><br><span class="line">  uint offset;  <span class="comment">// 段相对文件头的偏移值</span></span><br><span class="line">  uint va;     <span class="comment">// 段的第一个字节将被放到内存中的虚拟地址</span></span><br><span class="line">  uint pa;</span><br><span class="line">  uint filesz;</span><br><span class="line">  uint memsz;  <span class="comment">// 段在内存映像中占用的字节数</span></span><br><span class="line">  uint flags;</span><br><span class="line">  uint align;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="4"><li>读程序段到内存</li><li>执行程序</li></ol><h2 id="练习5实现函数调用堆栈跟踪函数-需要编程"><a class="markdownIt-Anchor" href="#练习5实现函数调用堆栈跟踪函数-需要编程"></a> 练习5：实现函数调用堆栈跟踪函数 （需要编程）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ebp:0x7b28 eip:0x100a63 args:0x10094 0x10094 0x7b58 0x100092</span><br><span class="line">    kern/debug/kdebug.c:308: print_stackframe+22</span><br><span class="line">ebp:0x7b38 eip:0x100d41 args:0x0 0x0 0x0 0x7ba8</span><br><span class="line">    kern/debug/kmonitor.c:126: mon_backtrace+11</span><br><span class="line">ebp:0x7b58 eip:0x100092 args:0x0 0x7b80 0xffff0000 0x7b84</span><br><span class="line">    kern/init/init.c:49: grade_backtrace2+34</span><br><span class="line">ebp:0x7b78 eip:0x1000bc args:0x0 0xffff0000 0x7ba4 0x29</span><br><span class="line">    kern/init/init.c:54: grade_backtrace1+39</span><br><span class="line">ebp:0x7b98 eip:0x1000db args:0x0 0x100000 0xffff0000 0x1d</span><br><span class="line">    kern/init/init.c:59: grade_backtrace0+24</span><br><span class="line">ebp:0x7bb8 eip:0x100101 args:0x1032bc 0x1032a0 0x130a 0x0</span><br><span class="line">    kern/init/init.c:64: grade_backtrace+35</span><br><span class="line">ebp:0x7be8 eip:0x100055 args:0x0 0x0 0x0 0x7c4f</span><br><span class="line">    kern/init/init.c:30: kern_init+85</span><br><span class="line">ebp:0x7bf8 eip:0x7d72 args:0xc031fcfa 0xc08ed88e 0x64e4d08e 0xfa7502a8</span><br><span class="line">    &lt;unknow&gt;: -- 0x00007d72 --</span><br></pre></td></tr></table></figure><p>%ebp中存储的当前的ebp地址，ebp地址中存储的是上一个ebp中的地址，于是根据当前的ebp寄存器的值可以递归查找到最底端的栈帧，而返回地址则是每个函数的%eip的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+|  栈底方向        | 高位地址</span><br><span class="line"> |    ...        |</span><br><span class="line"> |    ...        |</span><br><span class="line"> |  参数3        |</span><br><span class="line"> |  参数2        |</span><br><span class="line"> |  参数1        |</span><br><span class="line"> |  返回地址        |</span><br><span class="line"> |  上一层[ebp]    | &lt;-------- [ebp]</span><br><span class="line"> |  局部变量        |  低位地址</span><br></pre></td></tr></table></figure><h2 id="练习6完善中断初始化和处理-需要编程"><a class="markdownIt-Anchor" href="#练习6完善中断初始化和处理-需要编程"></a> 练习6：完善中断初始化和处理 （需要编程）</h2><h3 id="1-中断描述符表也可简称为保护模式下的中断向量表中一个表项占多少字节其中哪几位代表中断处理代码的入口"><a class="markdownIt-Anchor" href="#1-中断描述符表也可简称为保护模式下的中断向量表中一个表项占多少字节其中哪几位代表中断处理代码的入口"></a> 1. 中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？</h3><p>8个字节，16到31表示偏移量，48-63表示选择子，选择子到gdt里面获得基址，然后加上偏移量得到服务例程的地址。</p><h3 id="2-请编程完善kerntraptrapc中对中断向量表进行初始化的函数idt_init-在idt_init函数中依次对所有中断入口进行初始化-使用mmuh中的setgate宏填充idt数组内容-每个中断的入口由toolsvectorsc生成使用trapc中声明的vectors数组即可"><a class="markdownIt-Anchor" href="#2-请编程完善kerntraptrapc中对中断向量表进行初始化的函数idt_init-在idt_init函数中依次对所有中断入口进行初始化-使用mmuh中的setgate宏填充idt数组内容-每个中断的入口由toolsvectorsc生成使用trapc中声明的vectors数组即可"></a> 2. 请编程完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init。在idt_init函数中，依次对所有中断入口进行初始化。使用mmu.h中的SETGATE宏，填充idt数组内容。每个中断的入口由tools/vectors.c生成，使用trap.c中声明的vectors数组即可。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt;= <span class="number">255</span>; i++) &#123;</span><br><span class="line">        SETGATE(idt[i], <span class="number">0</span>, GD_KTEXT, __vectors[i], K_KERN);</span><br><span class="line">    &#125;</span><br><span class="line">    SETGATE(idt[T_SWITCH_TOU], <span class="number">1</span>, T_SYSCALL, __vectors[T_SWITCH_TOU], K_USER);</span><br><span class="line">    lidt(&amp;idt_pd);</span><br></pre></td></tr></table></figure><p>使用<code>SETGATE</code>填充<strong>idt</strong>表项，255项基本都是中断或异常，需要ring0的权限，只有80系统调用是ring3的权限，然后<code>lidt</code>将idt的地址填充到idtreg寄存器里面。</p><h3 id="3-请编程完善trapc中的中断处理函数trap在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分使操作系统每遇到100次时钟中断后调用print_ticks子程序向屏幕上打印一行文字100-ticks"><a class="markdownIt-Anchor" href="#3-请编程完善trapc中的中断处理函数trap在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分使操作系统每遇到100次时钟中断后调用print_ticks子程序向屏幕上打印一行文字100-ticks"></a> 3. 请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (++ticks == TICK_NUM) &#123;</span><br><span class="line">           print_ticks();</span><br><span class="line">           ticks = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h2 id="challenge-1"><a class="markdownIt-Anchor" href="#challenge-1"></a> Challenge 1</h2><h3 id="扩展proj4增加syscall功能即增加一用户态函数可执行一特定系统调用获得时钟计数值当内核初始完毕后可从内核态返回到用户态的函数而用户态的函数又通过系统调用得到内核态的服务通过网络查询所需信息可找老师咨询-如果完成且有兴趣做代替考试的实验可找老师商量-需写出详细的设计和分析报告-完成出色的可获得适当加分"><a class="markdownIt-Anchor" href="#扩展proj4增加syscall功能即增加一用户态函数可执行一特定系统调用获得时钟计数值当内核初始完毕后可从内核态返回到用户态的函数而用户态的函数又通过系统调用得到内核态的服务通过网络查询所需信息可找老师咨询-如果完成且有兴趣做代替考试的实验可找老师商量-需写出详细的设计和分析报告-完成出色的可获得适当加分"></a> 扩展proj4,增加syscall功能，即增加一用户态函数（可执行一特定系统调用：获得时钟计数值），当内核初始完毕后，可从内核态返回到用户态的函数，而用户态的函数又通过系统调用得到内核态的服务（通过网络查询所需信息，可找老师咨询。如果完成，且有兴趣做代替考试的实验，可找老师商量）。需写出详细的设计和分析报告。完成出色的可获得适当加分。</h3><h3 id="咕咕咕"><a class="markdownIt-Anchor" href="#咕咕咕"></a> 咕咕咕</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;练习一&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#练习一&quot;&gt;&lt;/a&gt; 练习一&lt;/h2&gt;
&lt;h3 id=&quot;操作系统镜像文件ucoreimg是如何一步一步生成的&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#操作系统镜像文件ucoreimg是如何一步一步生成的&quot;&gt;&lt;/a&gt; 操作系统镜像文件ucore.img是如何一步一步生成的？&lt;/h3&gt;
&lt;h4 id=&quot;1-构建kernel&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-构建kernel&quot;&gt;&lt;/a&gt; 1. 构建kernel&lt;/h4&gt;
    
    </summary>
    
    
      <category term="os" scheme="https://qinggniq.com/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round #572 (Div. 2) 题解</title>
    <link href="https://qinggniq.com/2019/07/06/Codeforces-Round-572-Answer/"/>
    <id>https://qinggniq.com/2019/07/06/Codeforces-Round-572-Answer/</id>
    <published>2019-07-06T04:47:01.000Z</published>
    <updated>2019-11-30T06:44:53.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="b-number-circle"><a class="markdownIt-Anchor" href="#b-number-circle"></a> <a href="http://codeforces.com/contest/1189/problem/B" target="_blank" rel="noopener">B. Number Circle</a></h2><h3 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h3><p>给n个数字<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_1, a_2, \ldots, a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，能否构成一个圈（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>相邻）使得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>&gt;</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_{i+1} + a_{i-1} &gt; a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.791661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.747431em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，如果是输出“YES”和相应序列（如果多个，输出任意一个），如果不能输出“NO”。<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>(</mo><mn>3</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">n(3\le n \le 10^5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>(</mo><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">a(1\le n \le 10^9)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><a id="more"></a><h3 id="样例"><a class="markdownIt-Anchor" href="#样例"></a> 样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">input</span><br><span class="line">3</span><br><span class="line">2 4 3</span><br><span class="line"></span><br><span class="line">output</span><br><span class="line">YES</span><br><span class="line">4 2 3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">input</span><br><span class="line">5</span><br><span class="line">1 2 3 4 4</span><br><span class="line"></span><br><span class="line">output</span><br><span class="line">YES</span><br><span class="line">4 4 2 1 3</span><br></pre></td></tr></table></figure><h3 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h3><p>将数字从小到大排序后发现，如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>&gt;</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_1 + a_{n-1} &gt; a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.747431em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>那么可以直接输出（因为a(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">1\le n \le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>)），否则将最大值和次大值交换位置，如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub><mo>+</mo><msub><mi>a</mi><mi>n</mi></msub><mo>&gt;</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{n-2} + a_{n} &gt; a_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.791661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>那么可以直接输出，否则不满足条件输出“NO”。第三大值和第二大值的和大于最大值是能构成圈的必要条件是显然的，是不是充分条件没想出来。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) <span class="built_in">cin</span> &gt;&gt; nums[i];</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="keyword">if</span> (nums[n<span class="number">-3</span>] + nums[n<span class="number">-2</span>] &lt;= nums[n<span class="number">-1</span>]) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; nums[n<span class="number">-3</span>] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-3</span>; ++i) <span class="built_in">cout</span> &lt;&lt; nums[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; nums[n<span class="number">-2</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; nums[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c-number-circle"><a class="markdownIt-Anchor" href="#c-number-circle"></a> <a href="http://codeforces.com/contest/1189/problem/C" target="_blank" rel="noopener">C. Number Circle</a></h2><h3 id="题意-2"><a class="markdownIt-Anchor" href="#题意-2"></a> 题意</h3><p>给<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>长度的序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><msup><mn>2</mn><mi>k</mi></msup></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">[a_1, a_2, \ldots, a_{2^k}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.49738em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7820285714285713em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2026199999999999em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>，每次都将其中的两个数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>a</mi><msup><mn>2</mn><mi>k</mi></msup></msub><mo separator="true">,</mo><msub><mi>a</mi><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>+</mo><mn>1</mn></mrow></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(a_{2^k}, a_{2^k+1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.010951em;vertical-align:-0.26095099999999993em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.49738em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7820285714285713em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2026199999999999em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.49738em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7820285714285713em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26095099999999993em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>替换为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>a</mi><msup><mn>2</mn><mi>k</mi></msup></msub><mo>+</mo><msub><mi>a</mi><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>+</mo><mn>1</mn></mrow></msub><mo>)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mn>10</mn></mrow><annotation encoding="application/x-tex">(a_{2^k} + a_{2^k+1}) mode 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.49738em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7820285714285713em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2026199999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.010951em;vertical-align:-0.26095099999999993em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.49738em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7820285714285713em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26095099999999993em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord">1</span><span class="mord">0</span></span></span></span>，然后获得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>长度的新序列，然后对这个新序列一直操作直到得到一个长度为1的序列。期间如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>a</mi><msup><mn>2</mn><mi>k</mi></msup></msub><mo>+</mo><msub><mi>a</mi><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>+</mo><mn>1</mn></mrow></msub><mo>)</mo><mo>&gt;</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">(a_{2^k} + a_{2^k+1}) &gt; 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.49738em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7820285714285713em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2026199999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.010951em;vertical-align:-0.26095099999999993em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.49738em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7820285714285713em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26095099999999993em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>那么可以获得一个糖果。给定这个序列，给定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>个查询，查询对序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>−</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l - r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>区间（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(r - l + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>是2的某个幂）进行操作后可以得到多少糖果。</p><h3 id="输入"><a class="markdownIt-Anchor" href="#输入"></a> 输入</h3><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> （序列长度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">(1\le n \le 10^5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>）<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mtext> </mtext><msub><mi>a</mi><mn>2</mn></msub><mtext> </mtext><msub><mi>a</mi><mn>3</mn></msub><mtext> </mtext><mo>…</mo><mtext> </mtext><msub><mi>a</mi><msup><mn>2</mn><mi>k</mi></msup></msub></mrow><annotation encoding="application/x-tex">a_1 ~ a_2 ~ a_3 ~ \ldots ~ a_{2^k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6331799999999999em;vertical-align:-0.2026199999999999em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace nobreak"> </span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace nobreak"> </span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.49738em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7820285714285713em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2026199999999999em;"><span></span></span></span></span></span></span></span></span></span> （序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">(1\le a_i \le 10^9)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>）<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>  （查询个数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo>≤</mo><mi>q</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">(1\le q \le 10^5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>）<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mn>1</mn></msub><mtext> </mtext><msub><mi>r</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">l_1 ~ r_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> （查询区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo>≤</mo><msub><mi>l</mi><mi>i</mi></msub><mo>≤</mo><msub><mi>r</mi><mi>i</mi></msub><mo>≤</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(1 \le l_i \le r_i \le n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>）<br>…<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mi>q</mi></msub><mtext> </mtext><msub><mi>r</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">l_q ~ r_q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p><h3 id="输出"><a class="markdownIt-Anchor" href="#输出"></a> 输出</h3><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><msub><mi>s</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">ans_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> （获得糖果数）<br>…<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><msub><mi>s</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">ans_q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p><h3 id="样例-2"><a class="markdownIt-Anchor" href="#样例-2"></a> 样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">intput</span><br><span class="line">8</span><br><span class="line">8 7 3 1 7 0 9 4</span><br><span class="line">3</span><br><span class="line">1 8</span><br><span class="line">2 5</span><br><span class="line">7 7</span><br><span class="line"></span><br><span class="line">output</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">input </span><br><span class="line">6</span><br><span class="line">0 1 2 3 3 5</span><br><span class="line">3</span><br><span class="line">1 2</span><br><span class="line">1 4</span><br><span class="line">3 6</span><br><span class="line"></span><br><span class="line">output</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h3><p>获得糖果的过程可以理解为满10减10的过程，然后获得多少糖果可以理解为减了多少次10（题解的证明也没怎么看懂），用前缀和查询区间和然后看能减多少次10就行了。</p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, q, l, r; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prefix(n+<span class="number">1</span>);</span><br><span class="line">    prefix[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">        prefix[i] = prefix[i<span class="number">-1</span>] + tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;q; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (prefix[r] - prefix[l<span class="number">-1</span>])/<span class="number">10</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;b-number-circle&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#b-number-circle&quot;&gt;&lt;/a&gt; &lt;a href=&quot;http://codeforces.com/contest/1189/problem/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;B. Number Circle&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&quot;题意&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题意&quot;&gt;&lt;/a&gt; 题意&lt;/h3&gt;
&lt;p&gt;给n个数字&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&quot;true&quot;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&quot;true&quot;&gt;,&lt;/mo&gt;&lt;mo&gt;…&lt;/mo&gt;&lt;mo separator=&quot;true&quot;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;a_1, a_2, \ldots, a_n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.625em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t vlist-t2&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.30110799999999993em;&quot;&gt;&lt;span style=&quot;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-s&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.15em;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t vlist-t2&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.30110799999999993em;&quot;&gt;&lt;span style=&quot;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-s&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.15em;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;minner&quot;&gt;…&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t vlist-t2&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.151392em;&quot;&gt;&lt;span style=&quot;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mathdefault mtight&quot;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-s&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.15em;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，能否构成一个圈（&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;a_1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.58056em;vertical-align:-0.15em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t vlist-t2&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.30110799999999993em;&quot;&gt;&lt;span style=&quot;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-s&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.15em;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;a_n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.58056em;vertical-align:-0.15em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t vlist-t2&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.151392em;&quot;&gt;&lt;span style=&quot;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mathdefault mtight&quot;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-s&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.15em;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;相邻）使得&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;a_{i+1} + a_{i-1} &amp;gt; a_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.791661em;vertical-align:-0.208331em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t vlist-t2&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.311664em;&quot;&gt;&lt;span style=&quot;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;&lt;span class=&quot;mord mathdefault mtight&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mbin mtight&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mord mtight&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-s&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.208331em;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.747431em;vertical-align:-0.208331em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t vlist-t2&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.311664em;&quot;&gt;&lt;span style=&quot;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;&lt;span class=&quot;mord mathdefault mtight&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mbin mtight&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mord mtight&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-s&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.208331em;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.58056em;vertical-align:-0.15em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t vlist-t2&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.31166399999999994em;&quot;&gt;&lt;span style=&quot;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mathdefault mtight&quot;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-s&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.15em;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，如果是输出“YES”和相应序列（如果多个，输出任意一个），如果不能输出“NO”。&lt;br&gt;
&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;n(3\le n \le 10^5)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;≤&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.7719400000000001em;vertical-align:-0.13597em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;≤&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1.064108em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.8141079999999999em;&quot;&gt;&lt;span style=&quot;top:-3.063em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;;&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;≤&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mn&gt;9&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;a(1\le n \le 10^9)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;≤&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.7719400000000001em;vertical-align:-0.13597em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;≤&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1.064108em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.8141079999999999em;&quot;&gt;&lt;span style=&quot;top:-3.063em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2019半年结</title>
    <link href="https://qinggniq.com/2019/07/03/Summary-of-Half-Year-in-2019/"/>
    <id>https://qinggniq.com/2019/07/03/Summary-of-Half-Year-in-2019/</id>
    <published>2019-07-03T11:33:51.000Z</published>
    <updated>2019-11-30T06:44:53.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动机"><a class="markdownIt-Anchor" href="#动机"></a> 动机</h2><p>半结的动机在于在家实在没有学习的心思，想通过总结来让自己静下心来。</p><a id="more"></a><h2 id="经历的事"><a class="markdownIt-Anchor" href="#经历的事"></a> 经历的事</h2><p>这半年分为两个部分，一个是我离开新浪去北航实验室做毕业设计，另一个是我离开北航回哈工程写准备毕业和面试。</p><h3 id="自闭又迷茫的毕设"><a class="markdownIt-Anchor" href="#自闭又迷茫的毕设"></a> 自闭又迷茫的毕设</h3><p>三月中旬的时候我从新浪离职去北航实验室做毕业设计，嗯由于我导的方向和未知原因，我在北航实验室的那两个月导师就没怎么管我，比如毕业设计和实验室方面的东西也没怎么过问。由于自己做毕设是用Standard ML写一个AADL的语法分析器，虽然学过《编译原理》，但是由于学艺不精能力不足，加上自己又从来没有学过SML，相关的资料也寥寥无几，所以在自己终于明白自己应该如何下手之前还是十分担心自己能不能毕业的，在那三月底的时候一直不知道是自己应该做什么，十分的迷茫。这是因为自己对做的工作不熟悉，<strong>无法预知完成时间</strong>导致的慌张，为什么人们常说<strong>DL是第一生产力</strong>，这句话有个前提是自己能够估计工作的完成时间（不管是正确的估计还是只是错觉），然后在DL之前工作虽然内心可能会慌张但是其实还是有自信做完的。然而当自己<strong>无法预知完成时间</strong>时，那句话便就不适用了，直到毕设后期我还是无法预估工作工作时间，所以直到我做完的时候才发现自己原来终于做完了，没有一点点估计。</p><p>仔细思考了一下自己当时做毕设的时候，三月中旬到四月初的时候我还是按照实习的日规划每天分给自己14:00-17:30这三个半小时做毕设的，当到四月初的时候我发现自己之前对于毕设的完成时间估计完全是错觉，我根本无法估计自己毕设的完成时间，所以之后我便将自己每天70%的工作时间留给了毕设，到五月初的时候终于完成了，如果现在我再估计自己能什么时候完成的话大概两周就可以完成我的毕业设计了，这是在我忽略掉调研、学习、调试的时间来说的所以这可能就是<strong>老手觉得新手菜</strong>的原因吧，新人和老人的区别往往不在于能力，而在于“做没做过”。</p><p>期间把科一给考了，科二因为对倒车入库的标准理解从根本上是错误的导致两次都直接挂在了这里。</p><h3 id="毫无进展的毕业"><a class="markdownIt-Anchor" href="#毫无进展的毕业"></a> 毫无进展的毕业</h3><p>五月中旬回学校忙论文和答辩，顺便找了一下暑期的日常实习。写论文和答辩便是正常进行了，在能估计完时间的情况下尽量拖延的完成了。但是和在实验室情况不同的是自己在写论文和准备面试、答辩的时候的时间管理变得十分的困难，在学校这一个半月学到的东西好像还没有自己正常半个月学的多吧。在情况不是可以预期不变、手头的工作不是那种定时完成的情况下，自己会很那去决定每天花多长时间在主要的工作上，比如写论文这件事情，这件时期主要分为“编写论文、画图、查/降重、调试格式错误”这几步，但是除了“查/降重”这件事是<strong>优化空间小</strong>的工作外，其他工作优化的空间都可以很大，比如调试格式错误基本就可以算是优化到天荒地老了，这样虽然自己可以预估自己大概的工作完成时间，但是这种预估是<strong>不考虑优化情况下的最少时间</strong>，然而实际上的时间可以是预估时间的几倍。然而这些东西也不是自己没法学习的实际原因，而是自己<strong>无法抉择在什么时候应该去做什么事情</strong>，如果按“紧急、重要”这两个维度来描述任务，写论文必然是重要的，但是紧不紧急取决于DL，“看书、学习”是重要的时期，但是决不是紧急的事情，这两个紧急程度不好排序的事情放到了一起，我便无法判断该优先做那件事情了，在加之实验室几乎没人学习工作，于是在无法抉择的时候被的被动选择了第三个事情——摸鱼。。</p><p>六月初的时候开始找实习，来来回回面了4家吧，一家都没过，文远知行面了一面后被告知不要研一的；晓链科技一面算法题不会Debug，写了一个Undefined Behavior；字节跳动三面操作系统题没回答好，对于自己模棱两可的知识点没有直接说不懂，而是强行解释，被面试官给看出来了，出了一道Buddy算法题把我给劝退了；图森未来一面不会写数位dp。在实习僧上投了大概三十多家，在牛客上也投十多家，除了文远知行和头条是直接推的外就只有两家是过了简历的，但也不是自己简历不好，毕竟yz也没多少面试。总结这几场面试除了客观因素（文远知行不要研一的）外，基本都是因为算法挂的，不过不这样算也不太准确，因为面的这四家除了头条问了基础知识之外其他的都没有问过基础知识。</p><ol><li>算法的训练没有止境</li><li>自己做的那个Server确实是有用的</li><li>基础知识方面就不要不懂装懂了，自己觉得还不错的Linux操作系统知识其实还远远不够</li></ol><h2 id="遇到的人"><a class="markdownIt-Anchor" href="#遇到的人"></a> 遇到的人</h2><h3 id="x师兄"><a class="markdownIt-Anchor" href="#x师兄"></a> X师兄</h3><p>北航实验室的师兄，和感兴趣的方向基本一致，Linux系统内核，系统架构岗，都是我希望的。他的路线和未来都是我可以借鉴的。</p><h2 id="读过的书-就不说了"><a class="markdownIt-Anchor" href="#读过的书-就不说了"></a> 读过的书、就不说了</h2><p>…</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>学无止境。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;动机&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#动机&quot;&gt;&lt;/a&gt; 动机&lt;/h2&gt;
&lt;p&gt;半结的动机在于在家实在没有学习的心思，想通过总结来让自己静下心来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="life" scheme="https://qinggniq.com/tags/life/"/>
    
  </entry>
  
  <entry>
    <title> 2019年规划（部分完成）</title>
    <link href="https://qinggniq.com/2019/07/03/Partially-Completed-Plan/"/>
    <id>https://qinggniq.com/2019/07/03/Partially-Completed-Plan/</id>
    <published>2019-07-03T11:28:59.000Z</published>
    <updated>2019-11-30T06:44:53.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>写这篇计划时正是在写完<a href="https://qinggniq.github.io/2019/01/22/2018%E5%B9%B4%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">2018年总结</a>后，yz提及暑假应该如何安排时的时候，我便写了这个[2019年规划]，结果写完之后就放到那里去了，也没在意过了，今日翻出来看看，发现自己定的目标多数没有完成，制定的计划也没怎么遵守，不免觉得惭愧。这是事物发展的自然规律，我定的计划不不执行和我自己的执行力大大有关，但是也和现实发展无法预测有很大关系。先把这份规划公开，好叫自己好好反省。</p><a id="more"></a><h2 id="动机"><a class="markdownIt-Anchor" href="#动机"></a> 动机</h2><p>今天正刷着牛客，看着充斥着屏幕的“2020届暑期实习内推”，忽然意识到自己是21届毕业生（如果能够顺利毕业的话，各种意义上的），明年的今天我也就要开始找实习了（如果老师允许的话），那仅仅这一年的时间，要是按我这个成长速度，明年的我还是那么的菜，肯定是找不着好实习的。<strong>危机感</strong>很重要，对于时间的把控也很重要，只有标注好timeline，自己才会清晰的意识到自己离目标还有多远，自己当前的状态是真的如自己想象的那样<strong>高效率</strong>，还是一种自我欺骗。</p><blockquote><p>要想努力的到什么，得先想想自己有什么。除了个人意志的努力外，我们还能借助的东西也许能让我们更快速地成长。</p></blockquote><h2 id="我想要什么"><a class="markdownIt-Anchor" href="#我想要什么"></a> 我想要什么</h2><h3 id="知识方面的"><a class="markdownIt-Anchor" href="#知识方面的"></a> 知识方面的</h3><ol><li>希望熟练掌握“C++后台开发”所需要的基础知识，在保证广度的情况下有一个方向的深度（亮点）</li><li>希望能够不被大多数的面试算法题难住，想不出最优解的情况下能够给出次优解或者大体思路</li><li>一个（多个）自己的个人项目，和后台开发相关的，即使细节部分不完善，也要知道项目各个部分的优化思路</li><li>多篇博客，并非简单抄书，也不是弱智Debug记录，要有<strong>动机、背景、概述、实践、比较、总结</strong>这些部分</li></ol><h3 id="人际方面的"><a class="markdownIt-Anchor" href="#人际方面的"></a> 人际方面的</h3><ol><li>希望能和同学、导师和睦相处</li><li>希望多和父母联系</li><li>希望能有一些不同圈子的朋友</li></ol><h2 id="我现在有什么"><a class="markdownIt-Anchor" href="#我现在有什么"></a> 我现在有什么</h2><h3 id="知识"><a class="markdownIt-Anchor" href="#知识"></a> 知识</h3><ol><li>还算过得去的操作系统、计算机网络、数据结构、C++语法、Linux基础知识（有广度，无深度）</li><li>leetcode刷题200道，大部分的miduem题目能够想出解来（无法保证最优解，bugfree）</li><li>已经有具体思路和借鉴对象的个人项目<strong>QG-Server</strong>（未完成，存在C/C++11语法混用的问题）</li><li>没有博客（在脑海中有几个TOPIC）</li></ol><h3 id="人脉虽然不想用这个词"><a class="markdownIt-Anchor" href="#人脉虽然不想用这个词"></a> 人脉（虽然不想用这个词）</h3><ol><li>几位ACM银牌（金牌实力）的室友</li><li>新浪微博带我的leader</li><li>leetcode打卡、交流群，有一些爱写博客的同学</li><li>牛客实习分享群</li><li>emacs、haskell群</li><li>实验室的师兄、导师</li><li>一位新闻专业的笔友</li></ol><h3 id="物质"><a class="markdownIt-Anchor" href="#物质"></a> 物质</h3><ol><li>一台带Apple pencial的Ipad</li><li>一台普通笔记本电脑</li><li>和同学共用的服务器</li><li>一些纸质书、电子书</li></ol><h2 id="怎么达到目标"><a class="markdownIt-Anchor" href="#怎么达到目标"></a> 怎么达到目标</h2><h3 id="知识方面"><a class="markdownIt-Anchor" href="#知识方面"></a> 知识方面</h3><ol><li>以项目为主导地学习（决定做项目，然后学相关知识）</li><li>以输出为主导地学习（决定写博客，然后学相关知识）</li><li>以面经为主导地学习（总结面试考点，然后逐个击破）</li><li>自顶向下地学习（先不在意细节，了解全局）</li><li><strong>扩宽自己知识的广度，眼界能帮助自己以小的代价得到更好的结果</strong></li></ol><h3 id="自我管理方面"><a class="markdownIt-Anchor" href="#自我管理方面"></a> 自我管理方面</h3><ol><li>学会使用<a href="https://baike.baidu.com/item/GTD/7384910?fr=aladdin" target="_blank" rel="noopener">GTD</a></li></ol><h3 id="人际交往方面"><a class="markdownIt-Anchor" href="#人际交往方面"></a> 人际交往方面</h3><ol><li>主动（方方面面的）</li><li>多与人交流自己的困惑</li><li>在做事情前多问问过来人的经验</li><li>找别人帮小忙</li><li>不要笑别人的短处，不要因为一己之快打消别人的热情</li></ol><h2 id="具体如何去做"><a class="markdownIt-Anchor" href="#具体如何去做"></a> 具体如何去做</h2><h3 id="知识方面-2"><a class="markdownIt-Anchor" href="#知识方面-2"></a> 知识方面</h3><table><thead><tr><th>主题</th><th>行为</th></tr></thead><tbody><tr><td>项目为主导</td><td>找到后台开发的典型项目，然后模仿它，再去学习相关知识</td></tr><tr><td>输出为主导</td><td>即以一个知识点作为主题进行cross reading，总结整理输出文章</td></tr><tr><td>面经为主导</td><td>“要点优先”的另一种表达方式，背题与刷题</td></tr><tr><td>自顶向下学习</td><td>利用Margin Note的树图方式进行学习</td></tr></tbody></table><h3 id="自我管理方面-2"><a class="markdownIt-Anchor" href="#自我管理方面-2"></a> 自我管理方面</h3><table><thead><tr><th>主题</th><th>行为</th></tr></thead><tbody><tr><td>GTD</td><td>目前我的用法过浅，对于复杂任务，除了给出目标，还应该给出自己设想的实现路径</td></tr></tbody></table><h3 id="人际交往方面-2"><a class="markdownIt-Anchor" href="#人际交往方面-2"></a> 人际交往方面</h3><table><thead><tr><th>主题</th><th>行为</th></tr></thead><tbody><tr><td>主动</td><td>不要等着别人来找自己说话，自己想要的、想知道的要主动去问</td></tr><tr><td>多与人交流自己的困惑</td><td>如题，但并不仅仅是学习上的困惑，生活上，情感上亦是</td></tr><tr><td>在做事情时问问过来人</td><td>万事开头难，过来人可以告诉自己难在哪里</td></tr><tr><td>找别人帮小忙</td><td>心理学上的效应，好好利用可以增进关系</td></tr><tr><td>不要笑话别人的短处，不要“杠”</td><td>对我自己讲的</td></tr></tbody></table><h2 id="具体规划"><a class="markdownIt-Anchor" href="#具体规划"></a> 具体规划</h2><h3 id="划分依据"><a class="markdownIt-Anchor" href="#划分依据"></a> 划分依据</h3><p>根据每个阶段需要force的内容来将自己的2019年进行划分。</p><h3 id="阶段工作内容"><a class="markdownIt-Anchor" href="#阶段工作内容"></a> 阶段工作内容</h3><table><thead><tr><th>月份</th><th>目标</th></tr></thead><tbody><tr><td>3-6</td><td>完成毕业设计，找到后台日常实习</td></tr><tr><td>7-8</td><td>实习</td></tr><tr><td>9-12</td><td>在实验室学习</td></tr></tbody></table><p>就这三个阶段，每个阶段的工作具体规划如下。</p><h3 id="3-6月"><a class="markdownIt-Anchor" href="#3-6月"></a> 3-6月</h3><h4 id="毕业设计基于sml的aadl语法分析器-准备面试与参加面试"><a class="markdownIt-Anchor" href="#毕业设计基于sml的aadl语法分析器-准备面试与参加面试"></a> 毕业设计：基于SML的AADL语法分析器 &amp;&amp; 准备面试与参加面试</h4><table><thead><tr><th>时间</th><th>毕业设计目标</th><th>面试准备目标</th></tr></thead><tbody><tr><td>1-2周(3.10 - 3.24)</td><td>完成AADL的词法分析器</td><td>再次开刷CyCy的面经，重新用C++刷Leetcode的Top Like and Top Interview 100题，完成<strong>QG-Server</strong>的一个模块</td></tr><tr><td>2-4周(3.25 - 4.6)</td><td>调研并开启AADL语法分析器的编码</td><td>完成<strong>QG-Server</strong>的代码编写，并开始整理后端服务器开发的相关技术，编写文档，继续刷leetcode</td></tr><tr><td>5-6周(4.7 - 4.20)</td><td>完成语法分析器的编码，开始撰写毕业论文</td><td>完成<strong>QG-Server</strong>的文档编写，开始投递简历，开始面试，同时认真复盘面试</td></tr><tr><td>7-8周(4.21 - 5.6)</td><td>完成毕业论文</td><td>如果没找到实习继续投递简历，并完善<strong>QG-Server</strong>或者开启新的个人项目</td></tr><tr><td>9-10周(5.7 - 5.20)</td><td>准备毕业答辩</td><td>开启新的项目或者补充<strong>QG-Server</strong>，将要读的书籍阅读</td></tr><tr><td>11-14周(5.21 - 7.4)</td><td>毕业答辩，毕业旅行或者实习</td><td>项目、书籍、leetcode</td></tr></tbody></table><h4 id="每天的规划初定"><a class="markdownIt-Anchor" href="#每天的规划初定"></a> 每天的规划（初定）</h4><table><thead><tr><th>时间</th><th>工作内容</th></tr></thead><tbody><tr><td>8-9</td><td>起床，吃饭，列每日工作目标</td></tr><tr><td>9-10</td><td>刷leetcode</td></tr><tr><td>10-11</td><td>看面经、背面经 or 写项目文档</td></tr><tr><td>11-12</td><td>思考、计划下午要进行的代码</td></tr><tr><td>12-12:30</td><td>吃午餐</td></tr><tr><td>12:30-13</td><td>看小说放松、写信</td></tr><tr><td>13-14</td><td>睡午觉</td></tr><tr><td>14-17</td><td>看代码、写毕设代码</td></tr><tr><td>17-17:30</td><td>吃晚餐</td></tr><tr><td>17:30-18</td><td>看小说 or 写信 or 散步</td></tr><tr><td>18-20</td><td>看论文、写代码（毕社 or 个人）</td></tr><tr><td>20-21:30</td><td>写个人项目代码</td></tr><tr><td>21:30-22</td><td>总结、反思、写日记</td></tr><tr><td>22-22:30</td><td>锻炼</td></tr><tr><td>22:30-23:30</td><td>娱乐（游戏 or 看小说）</td></tr></tbody></table><p>这个时间规划可能会因为早上要练车、蹭课而变化。</p><h3 id="7-8月"><a class="markdownIt-Anchor" href="#7-8月"></a> 7-8月</h3><p>看情况，如果实习内容感觉不值得浪费时间的话，每日安排就和目前的安排差不多，如果不是的话，那就花更多的时间在实习内容上了。</p><h3 id="9-12月"><a class="markdownIt-Anchor" href="#9-12月"></a> 9-12月</h3><p>在实验室，上课，接触实验室课题、做个人项目，那个时候的时间安排就得随机应变了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#背景&quot;&gt;&lt;/a&gt; 背景&lt;/h2&gt;
&lt;p&gt;写这篇计划时正是在写完&lt;a href=&quot;https://qinggniq.github.io/2019/01/22/2018%E5%B9%B4%E6%80%BB%E7%BB%93/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;2018年总结&lt;/a&gt;后，yz提及暑假应该如何安排时的时候，我便写了这个[2019年规划]，结果写完之后就放到那里去了，也没在意过了，今日翻出来看看，发现自己定的目标多数没有完成，制定的计划也没怎么遵守，不免觉得惭愧。这是事物发展的自然规律，我定的计划不不执行和我自己的执行力大大有关，但是也和现实发展无法预测有很大关系。先把这份规划公开，好叫自己好好反省。&lt;/p&gt;
    
    </summary>
    
    
      <category term="life" scheme="https://qinggniq.com/tags/life/"/>
    
  </entry>
  
</feed>
